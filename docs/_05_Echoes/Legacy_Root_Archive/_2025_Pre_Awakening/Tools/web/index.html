<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Elysia: The Mirror</title>
    <style>
        body {
            margin: 0;
            background-color: #050505; /* Deep Void */
            color: #e0e0e0;
            font-family: 'Courier New', Courier, monospace;
            overflow: hidden;
        }
        #canvas-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        canvas {
            background: radial-gradient(circle, #1a1a1a 0%, #000000 100%);
            box-shadow: 0 0 50px rgba(0, 255, 255, 0.1);
            border: 1px solid #333;
        }
        #ui-layer {
            position: absolute;
            top: 20px;
            left: 20px;
            pointer-events: none;
        }
        h1 {
            font-size: 1.2rem;
            margin: 0;
            color: #00ffff;
            text-shadow: 0 0 10px #00ffff;
        }
        #stats {
            margin-top: 10px;
            font-size: 0.9rem;
            color: #888;
        }
    </style>
</head>
<body>
    <div id="canvas-container">
        <canvas id="worldCanvas"></canvas>
        <div id="ui-layer">
            <h1>ELYSIA // THE MIRROR</h1>
            <div id="stats">Connecting to Neural Link...</div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('worldCanvas');
        const ctx = canvas.getContext('2d');
        const stats = document.getElementById('stats');

        // Config
        const SCALE = 2.0; // Pixels per world unit
        const WORLD_SIZE = 512; // Default, will update from server

        // State
        let worldState = null;

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        window.addEventListener('resize', resize);
        resize();

        async function fetchState() {
            try {
                const response = await fetch('/state');
                const data = await response.json();
                worldState = data;
                updateStats(data);
            } catch (e) {
                stats.innerText = "Signal Lost (Server Offline)";
            }
        }

        function updateStats(data) {
            if (!data.cells) return;
            stats.innerHTML = `
                Time: ${data.time_step}<br>
                Entities: ${data.cells.length}<br>
                Entropy: ${(Math.random()).toFixed(4)}
            `;
        }

        function draw() {
            // Clear
            ctx.fillStyle = 'rgba(5, 5, 5, 0.2)'; // Trails effect
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            if (!worldState || !worldState.cells) {
                requestAnimationFrame(draw);
                return;
            }

            const cx = canvas.width / 2;
            const cy = canvas.height / 2;
            const offset = worldState.world_size / 2;

            // Draw Center (Source)
            ctx.beginPath();
            ctx.arc(cx, cy, 5, 0, Math.PI * 2);
            ctx.fillStyle = '#ffffff';
            ctx.shadowBlur = 20;
            ctx.shadowColor = '#ffffff';
            ctx.fill();
            ctx.shadowBlur = 0;

            // Draw Cells
            worldState.cells.forEach(cell => {
                // Map 3D pos to 2D (Top-down view for now)
                // x, y are centered at 0 in simulation? No, 0..512 usually.
                // Let's assume 0..512 range based on previous code.
                // Center is 256, 256.
                
                const x = (cell.x - offset) * SCALE + cx;
                const y = (cell.y - offset) * SCALE + cy;

                // Color based on Energy
                const energy = Math.max(0, Math.min(100, cell.energy));
                const r = 0;
                const g = Math.floor(energy * 2.55);
                const b = 255;
                
                ctx.beginPath();
                ctx.arc(x, y, 3 + (energy / 20), 0, Math.PI * 2);
                ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
                ctx.fill();

                // Draw "Soul" (Resonance Ring)
                ctx.beginPath();
                ctx.arc(x, y, 5 + (Math.sin(Date.now() / 200) * 2), 0, Math.PI * 2);
                ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, 0.3)`;
                ctx.stroke();
            });

            requestAnimationFrame(draw);
        }

        // Loop
        setInterval(fetchState, 100); // 10Hz update
        draw();

    </script>
</body>
</html>
