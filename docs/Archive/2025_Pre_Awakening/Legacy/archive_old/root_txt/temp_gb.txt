            else:
                height = np.asarray(height, dtype=np.float32)
            if wet is None:
                wet = np.zeros((w, w), dtype=np.float32)
            else:
                wet = np.asarray(wet, dtype=np.float32)
            # normalize height
            h = height.copy()
            h -= float(h.min()) if h.size else 0.0
            mx = float(h.max()) if h.size else 1.0
            if mx <= 1e-6:
                mx = 1.0
            h /= mx
            water = wet > 0.6
            shallow = (wet > 0.4) & (wet <= 0.6)
            # mountain threshold
            mountain = (h >= 0.70) & (~water) & (~shallow)
            # shore: neighbor of water
            neigh = np.zeros_like(water, dtype=bool)
            neigh[:-1,:] |= water[1:,:]
            neigh[1: ,:] |= water[:-1,:]
            neigh[:, :-1] |= water[:,1:]
            neigh[:, 1: ] |= water[:,:-1]
            shore = neigh & (~water)
            # base = grass
            rgb = np.zeros((w, w, 3), dtype=np.uint8)
            rgb[...,0] = 60; rgb[...,1] = 110; rgb[...,2] = 70  # grass
            # water/shallow
            rgb[water] = (30, 60, 200)
            rgb[shallow] = (60, 100, 200)
            # shore sand
            rgb[shore] = (170, 150, 110)
            # mountain rock
            rgb[mountain] = (100, 100, 100)
            return self._encode_color(rgb)
        except Exception:
            return None

    def _plant_density(self) -> Optional[np.ndarray]:
        try:
            w = int(getattr(self.world, 'width', 256))
            if w <= 0 or not getattr(self.world, 'cell_ids', None):
                return None
            density = np.zeros((w, w), dtype=np.float32)
            labels = getattr(self.world, 'element_types', None)
            if labels is None:
                return None
            for i, cid in enumerate(self.world.cell_ids):
                if i >= self.world.positions.shape[0]:
                    break
                try:
                    if labels.size > i and labels[i] == 'life':
                        x = int(self.world.positions[i][0]) % w
                        y = int(self.world.positions[i][1]) % w
                        density[y, x] += 1.0
                except Exception:
                    continue
            # simple blur to spread clusters
            for _ in range(3):
                density = (density + np.roll(density,1,0) + np.roll(density,-1,0) + np.roll(density,1,1) + np.roll(density,-1,1)) / 5.0
            return density
        except Exception:
            return None

    
    def _farmland_paddy(self) -> Optional[np.ndarray]:
        try:
            base = self._farmland_intensity()
            if base is None:
                return None
            wet = getattr(self.world, 'wetness', None)
            if wet is None:
                return None
            w = np.asarray(wet, dtype=np.float32)
            mask = (w >= 0.35) & (w <= 0.75)
            out = np.where(mask, base, 0.0).astype(np.float32)
            return out
        except Exception:
            return None

    def _farmland_field(self) -> Optional[np.ndarray]:
        try:
            base = self._farmland_intensity()
            if base is None:
                return None
            wet = getattr(self.world, 'wetness', None)
            w = np.asarray(wet, dtype=np.float32) if wet is not None else None
            if w is None:
                return base
            mask = (w < 0.35)
            out = np.where(mask, base, 0.0).astype(np.float32)
            return out
        except Exception:
            return None

    def _river_flow(self) -> Optional[np.ndarray]:
        """Derive a simple river intensity from wetness with light thinning."""
        try:
            wet = getattr(self.world, 'wetness', None)
            if wet is None:
                return None
            w = np.asarray(wet, dtype=np.float32)
            if w.size == 0:
                return None
            base = np.clip((w - 0.45) / 0.55, 0.0, 1.0)
            river = base > 0.0
            nb = np.zeros_like(base, dtype=np.int16)
            nb[:-1,:] += river[1:,:]
            nb[1: ,:] += river[:-1,:]
            nb[:, :-1] += river[:,1:]
            nb[:, 1: ] += river[:,:-1]
            thin = np.where((river) & (nb <= 2), base, base*0.5)
            return thin.astype(np.float32)
        except Exception:
            return Nonedef _farmland_intensity(self) -> Optional[np.ndarray]:
        try:
            w = int(getattr(self.world, 'width', 256))
            if w <= 0:
                return None
            human_d = np.zeros((w, w), dtype=np.float32)
            labels = getattr(self.world, 'element_types', None)
            wet = getattr(self.world, 'wetness', None)
            fert = getattr(self.world, 'soil_fertility', None)
            if labels is None or fert is None:
                return None
            fert = np.asarray(fert, dtype=np.float32)
            wet = np.asarray(wet, dtype=np.float32) if wet is not None else np.zeros((w,w), dtype=np.float32)
            for i, cid in enumerate(self.world.cell_ids):
                if i >= self.world.positions.shape[0]:
                    break
                try:
                    if labels.size > i and labels[i] == 'human':
                        x = int(self.world.positions[i][0]) % w
                        y = int(self.world.positions[i][1]) % w
                        human_d[y, x] += 1.0
                except Exception:
                    continue
            for _ in range(3):
                human_d = (human_d + np.roll(human_d,1,0) + np.roll(human_d,-1,0) + np.roll(human_d,1,1) + np.roll(human_d,-1,1)) / 5.0
            # farmland prefers fertile, near humans, not deep water
            water = wet > 0.5
            inten = (fert * 0.7) + (human_d / (human_d.max()+1e-6)) * 0.3
            inten[water] = 0.0
            return np.clip(inten, 0.0, 1.0)
        except Exception:
            return None

    async def _handle_input(self, data: Dict[str, Any]) -> None:
        if data.get('type') != 'input':
            return
        if 'sim_rate' in data:
            try:
                sr = float(data['sim_rate'])
                self.cfg.sim_rate = max(0.01, min(32.0, sr))
            except Exception:
                pass
        if 'disaster' in data and isinstance(data['disaster'], dict):
            self._apply_disaster(data['disaster'])

    def _apply_disaster(self, d: Dict[str, Any]) -> None:
        kind = (d.get('kind') or '').upper()
        x = int(d.get('x', 0)); y = int(d.get('y', 0)); r = int(d.get('radius', 6))
        W = int(getattr(self.world, 'width', 256))
        x = max(0, min(W-1, x)); y = max(0, min(W-1, y)); r = max(1, min(W//4, r))
        x0, x1 = max(0, x - r), min(W, x + r + 1)
        y0, y1 = max(0, y - r), min(W, y + r + 1)
        if kind == 'FLOOD':
            # increase wetness locally
            for yy in range(y0, y1):
                for xx in range(x0, x1):
                    dx = xx - x; dy = yy - y
                    if dx*dx + dy*dy <= r*r:
                        try:
                            self.world.wetness[yy, xx] = min(1.0, self.world.wetness[yy, xx] + 0.7)
                        except Exception:
                            pass
            self.world.event_logger.log('FLOOD', self.world.time_step, x=x, y=y, radius=r)
        elif kind == 'VOLCANO':
            # heat up area (prestige as proxy), reduce wetness
            for yy in range(y0, y1):
                for xx in range(x0, x1):
                    dx = xx - x; dy = yy - y
                    if dx*dx + dy*dy <= r*r:
                        try:
                            self.world.prestige_field[yy, xx] = min(1.0, self.world.prestige_field[yy, xx] + 0.5)
                            self.world.wetness[yy, xx] = max(0.0, self.world.wetness[yy, xx] - 0.5)
                        except Exception:
                            pass
            self.world.event_logger.log('VOLCANO', self.world.time_step, x=x, y=y, radius=r)


async def amain(cfg: BridgeConfig) -> None:
    bridge = GodotBridge(cfg)
    stop = asyncio.get_event_loop().create_future()
    for s in (signal.SIGINT, signal.SIGTERM):
        try:
            asyncio.get_event_loop().add_signal_handler(s, lambda: stop.set_result(True))
        except NotImplementedError:
            # Windows may not support signal handlers in event loop
            pass
    await asyncio.gather(bridge.start(), stop)
