import pygame
import sys
import random
from typing import Dict
from unittest.mock import MagicMock
import numpy as np

# ��� �߰�
sys.path.append('.')
from Project_Elysia.core.divine_engine import ElysiaDivineEngineV2
from Project_Sophia.core.world import World
from Project_Sophia.wave_mechanics import WaveMechanics
from tools.kg_manager import KGManager


# --- ���� ---
SCREEN_WIDTH = 1600
SCREEN_HEIGHT = 900
BACKGROUND_COLOR = (10, 10, 20)
CURRENT_NODE_COLOR = (255, 255, 0)
BRANCH_COLORS = {"main": (0, 150, 255), "civilization": (100, 200, 120)}
LINE_COLOR = (100, 100, 120)
FONT_COLOR = (200, 200, 220)
NODE_RADIUS = 5


# --- Pygame �ʱ�ȭ ---
pygame.init()
screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))
pygame.display.set_caption("Elysia Divine Engine & Cell World - Integrated Visualization")
font = pygame.font.SysFont("sans-serif", 24)
clock = pygame.time.Clock()

# --- Mock ��ü �� �ʱ�ȭ ---
kg_manager = KGManager()
mock_wave_mechanics = MagicMock(spec=WaveMechanics)
mock_wave_mechanics.kg_manager = kg_manager

engine = ElysiaDivineEngineV2()
world = World(primordial_dna={'instinct': 'survive'}, wave_mechanics=mock_wave_mechanics)
# World ��ü�� width�� height �Ӽ��� �������� �߰�
world.width = 100
world.height = 100


# --- �ʱ� ���� ---
world.add_cell("human", properties={"x": 50, "y": 50, "name": "Adam", "culture": "primitive", "element_type": "animal", "label": "human", "diet": "omnivore"})
engine.ingest({
    'truth': 1.0, 'emotion': 0.5, 'causality': 0.5, 'beauty': 0.5,
    'meta': {'world_population': world.get_population_summary()}
}, note="Genesis", scopes=['elysia_core', 'civilization'])


# --- �ð�ȭ �Լ� ---
def get_branch_color(branch_id: str):
    if branch_id not in BRANCH_COLORS:
        random.seed(branch_id)
        BRANCH_COLORS[branch_id] = (random.randint(50, 200), random.randint(50, 200), random.randint(50, 200))
    return BRANCH_COLORS[branch_id]

def draw_timescape(engine_instance: ElysiaDivineEngineV2):
    node_positions: Dict[str, tuple[int, int]] = {}
    branch_y_level: Dict[str, int] = {"main": 0}
    y_levels_occupied = {0}
    y_base = SCREEN_HEIGHT // 2
    y_spacing = 100
    x_spacing = 60

    sorted_branches = sorted(engine_instance.branches.items(), key=lambda item: (item[0] != 'main', item[1].origin_node_id or ''))

    for branch_id, branch in sorted_branches:
        if branch.origin_node_id and branch.origin_node_id in node_positions:
            parent_branch_id = engine_instance.nodes[branch.origin_node_id].branch_id
            parent_y_level = branch_y_level[parent_branch_id]
            new_y_level = parent_y_level + 1
            while new_y_level in y_levels_occupied:
                new_y_level += 1
            branch_y_level[branch_id] = new_y_level
            y_levels_occupied.add(new_y_level)
            start_x = node_positions[branch.origin_node_id][0]
        else:
            branch_y_level[branch_id] = 0
            start_x = 50

        y_pos = y_base - branch_y_level[branch_id] * y_spacing

        for i, node_id in enumerate(branch.nodes):
            x_pos = start_x + (i + 1) * x_spacing
            node_positions[node_id] = (x_pos, y_pos)

    for node_id, pos in node_positions.items():
        node = engine_instance.nodes.get(node_id)
        if node and node.parent_id and node.parent_id in node_positions:
            pygame.draw.line(screen, LINE_COLOR, node_positions[node.parent_id], pos, 1)

    for node_id, pos in node_positions.items():
        node = engine_instance.nodes.get(node_id)
        if not node: continue
        color = CURRENT_NODE_COLOR if node_id == engine_instance.current_node_id else get_branch_color(node.branch_id)
        pygame.draw.circle(screen, color, pos, NODE_RADIUS)
        if node.note:
            text_surf = font.render(node.note, True, FONT_COLOR)
            screen.blit(text_surf, (pos[0] + 10, pos[1] - 10))

def draw_world_minimap(world_instance: World, position: tuple[int, int], size: tuple[int, int]):
    minimap_surface = pygame.Surface(size)
    minimap_surface.fill((0, 0, 0))
    minimap_surface.set_alpha(180)
    cell_color_map = {"human": (255, 255, 255), "plant": (0, 255, 0), "animal": (255, 100, 100), "wolf": (200, 0, 0)}

    living_indices = np.where(world_instance.is_alive_mask)[0]
    for idx in living_indices:
        # Check if positions array is large enough
        if idx < len(world_instance.positions):
            x_pos, y_pos, _ = world_instance.positions[idx]
            # Use getattr to safely access width/height
            world_width = getattr(world_instance, 'width', 100)
            world_height = getattr(world_instance, 'height', 100)
            x_ratio = x_pos / world_width
            y_ratio = y_pos / world_height
            map_x = int(x_ratio * size[0])
            map_y = int(y_ratio * size[1])
            label = world_instance.labels[idx]
            color = cell_color_map.get(label, (150, 150, 150))
            if 0 <= map_x < size[0] and 0 <= map_y < size[1]:
                minimap_surface.set_at((map_x, map_y), color)
    screen.blit(minimap_surface, position)

# --- ���� ���� ---
running = True
time_acceleration = 1.0
time_since_last_step = 0.0

while running:
    delta_time = clock.tick(60) / 1000.0
    time_since_last_step += delta_time

    for event in pygame.event.get():
        if event.type == pygame.QUIT: running = False
        if event.type == pygame.KEYDOWN:
            if event.key == pygame.K_q: running = False
            elif event.key == pygame.K_LEFT: engine.rewind()
            elif event.key == pygame.K_RIGHT: engine.fast_forward()
            elif event.key == pygame.K_UP: time_acceleration *= 1.5
            elif event.key == pygame.K_DOWN: time_acceleration /= 1.5
            elif event.key == pygame.K_SPACE:
                engine.edit_fate({'truth': random.random(), 'emotion': random.random(), 'causality': random.random(), 'beauty': random.random()}, note="New Global Fate")

    if time_acceleration > 0 and time_since_last_step >= 1.0 / time_acceleration:
        time_since_last_step = 0.0
        world.run_simulation_step()
        population = world.get_population_summary()
        total_population = sum(population.values())
        if total_population == 0 and world.time_step > 10:
            time_acceleration = 0

        experience_meta = {'world_population': population, 'tick': world.time_step}
        engine.ingest({
            'truth': 1.0, 'emotion': min(1.0, total_population / 20.0), 'causality': 0.7, 'beauty': random.random(), 'meta': experience_meta
        }, note=f"Tick {world.time_step}", scopes=['civilization'])

    screen.fill(BACKGROUND_COLOR)
    draw_timescape(engine)
    draw_world_minimap(world, (SCREEN_WIDTH - 310, 10), (300, 300))

    pop_summary = world.get_population_summary()
    info_text1 = f"Time Acceleration: {time_acceleration:.2f}x | Divine Nodes: {len(engine.nodes)}"
    info_text2 = f"World Tick: {world.time_step} | Population: {sum(pop_summary.values())} ({pop_summary})"

    text_surf1 = font.render(info_text1, True, FONT_COLOR)
    text_surf2 = font.render(info_text2, True, FONT_COLOR)
    screen.blit(text_surf1, (10, 10))
    screen.blit(text_surf2, (10, 40))

    pygame.display.flip()

pygame.quit()
sys.exit()
