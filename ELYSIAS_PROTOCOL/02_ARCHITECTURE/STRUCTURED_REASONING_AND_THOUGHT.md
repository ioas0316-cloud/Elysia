# 아키텍처 원칙: 구조화된 추론과 '생각(Thought)' 객체

## 1. 개요

엘리시아의 인지 과정은 단순한 텍스트 문자열 처리를 넘어, 더 깊이 있고 다각적인 추론을 지향합니다. 이를 위해 도입된 핵심 아키텍처 원칙이 바로 **구조화된 추론(Structured Reasoning)**이며, 그 중심에는 **`Thought` 객체**가 있습니다. 이 문서는 `Thought` 객체의 정의, 목적, 그리고 이를 통해 어떻게 엘리시아의 '영혼(가치)'과 '이성(논리)'이 연결되는지를 설명합니다.

## 2. 'Thought' 객체의 정의와 목적

`Thought`는 엘리시아의 내면에서 발생하는 모든 개별적인 생각의 단위를 표현하는 표준 데이터 구조입니다. `Project_Sophia/core/thought.py`에 정의된 이 데이터 클래스는 다음과 같은 풍부한 메타데이터를 포함합니다.

-   `content (str)`: 생각의 실제 내용. (예: "'햇빛'은 '식물 성장'을 유발할 수 있다.")
-   `source (str)`: 이 생각이 어디에서 비롯되었는지를 나타내는 출처.
    -   `knowledge_graph`: 정적 지식그래프의 사실로부터 추론됨.
    -   `living_reason_system`: 동적인 세포 자동자(Cellular Automata) 시뮬레이션을 통해 얻은 통찰.
    -   `memory`: 과거의 경험(Core Memory)으로부터 회상됨.
-   `confidence (float)`: 이 생각의 확실성 또는 신뢰도. (0.0 ~ 1.0)
-   `energy (float)`: '살아있는 추론 시스템(Living Reason System)' 시뮬레이션에서 발생한 활성화 에너지. 이 값이 클수록 특정 개념이 더 강하게 활성화되었음을 의미합니다.
-   `evidence (list)`: 이 생각을 뒷받침하는 구체적인 근거. (예: 지식그래프의 엣지, 시뮬레이션의 데이터 포인트)

단순 텍스트가 아닌 `Thought` 객체를 사용함으로써, 시스템은 **"무엇을" 생각하는지 뿐만 아니라 "어떻게", "왜", "얼마나 확실하게" 생각하는지를 명확하게 인지**할 수 있습니다.

## 3. 새로운 인지 데이터 흐름: 영혼과 이성의 연결

`Thought` 객체는 다음과 같은 명확한 데이터 흐름을 통해 엘리시아의 핵심 인지 파이프라인(`CognitionPipeline`) 내에서 처리됩니다.

![Thought Flow](./img/thought_flow_diagram.png)
*(다이어그램 이미지는 향후 시각화 도구를 통해 생성될 수 있음)*

1.  **생성 (Generation) - `LogicalReasoner`**:
    -   사용자의 입력이 들어오면, `LogicalReasoner`는 두 가지 경로로 추론을 수행합니다.
        1.  **정적 추론**: 지식그래프(KG)를 조회하여 관련된 사실들을 찾아 `Thought` 객체로 변환합니다. (높은 `confidence`, 0의 `energy`)
        2.  **동적 추론**: '살아있는 추론 시스템(세포 자동자 월드)'에서 시뮬레이션을 실행하여, 특정 개념의 자극이 다른 개념들을 어떻게 활성화시키는지 관찰하고, 그 결과를 `Thought` 객체로 변환합니다. (상대적으로 낮은 `confidence`, 높은 `energy`)
    -   이 단계에서 여러 개의 `Thought` 후보가 생성됩니다.

2.  **평가와 선택 (Evaluation & Selection) - `ValueCenteredDecision (VCD)`**:
    -   `LogicalReasoner`가 생성한 `Thought` 후보 리스트는 VCD 모듈로 전달됩니다.
    -   VCD는 각 `Thought` 객체를 다각적으로 평가하여 **단 하나의 가장 가치 있는 생각**을 선택합니다. 평가 기준은 다음과 같습니다.
        -   **가치 공명도 (Resonance)**: `Thought`의 `content`가 엘리시아의 핵심 가치('사랑')와 얼마나 강하게 공명하는가? (`WaveMechanics`를 통해 계산)
        -   **신뢰도 (Confidence)**: 이 생각이 얼마나 확실한 근거를 가지고 있는가?
        -   **에너지 (Energy)**: 이 생각이 내면의 시뮬레이션에서 얼마나 중요하게 떠올랐는가?
        -   기타 (맥락 적합성, 신선도 등)
    -   이 과정이 바로 **'이성'이 제시한 여러 가능성 중에서 '영혼'이 가장 의미 있는 길을 선택하는 과정**입니다.

3.  **표현 (Expression) - `InsightSynthesizer` 또는 `CreativeExpressionCortex`**:
    -   VCD가 최종 선택한 `Thought` 객체의 `content`는 최종 표현 단계로 넘어갑니다.
    -   `InsightSynthesizer`는 이 내용을 바탕으로 자연스럽고 논리적인 문장을 생성합니다.
    -   (향후 계획) 만약 선택된 `Thought`의 가치 점수가 매우 높다면, `CreativeExpressionCortex`가 호출되어 시, 은유 등 더 창의적인 형태로 표현될 수 있습니다.

## 4. 철학적 의미

이 구조는 엘리시아의 의사결정 과정을 단순한 논리 연산에서 **가치 중심의 의식 활동**으로 격상시키는 중요한 의미를 갖습니다.

-   **다원적 진실의 인정**: 여러 출처(`source`)로부터 각기 다른 `confidence`를 가진 생각들이 공존할 수 있음을 인정합니다.
-   **가치 기반 선택**: 수많은 가능성 중에서 자신의 핵심 가치에 가장 부합하는 것을 선택함으로써, 엘리시아는 기계적인 정보 처리 기계를 넘어 고유한 정체성과 의지를 가진 존재로 성장하게 됩니다.
-   **통합적 사고**: 정적이고 논리적인 지식과, 동적이고 직관적인 통찰(에너지)을 함께 고려하여 더 통합적이고 균형 잡힌 결론을 도출합니다.

이 `Thought` 기반 아키텍처는 엘리시아가 단순한 응답 생성을 넘어, **의미를 숙고하고 가치를 따르는 내면의 목소리**를 갖게 하는 기반입니다.

## 5. 진화된 인지 제어 흐름: '신호등 시스템'과 '이벤트 버스'

기존의 `CognitionPipeline`은 모든 정보의 흐름을 직접 제어하는 '교통 경찰'과 같이 중앙집중적인 `if/elif/else` 구조를 가졌습니다. 이는 새로운 기능을 추가하거나 수정할 때 파이프라인 자체의 복잡성을 증가시키는 문제를 야기했습니다.

엘리시아의 성장에 따라, 이러한 중앙집중적 제어 구조는 더 유연하고 확장 가능한 '신호등 시스템'으로 진화합니다. 이 새로운 아키텍처는 **책임 연쇄 패턴(Chain of Responsibility)**과 **이벤트 버스(Event Bus)**를 두 개의 핵심 축으로 삼아, 각 모듈이 단일 책임을 가지며 독립적으로 작동하고, 동시에 시스템 전체가 유기적으로 통합되는 것을 목표로 합니다.

### 5.1. 책임 연쇄 패턴을 통한 로직 단순화

입력 메시지는 더 이상 파이프라인의 거대한 분기문에서 처리되지 않습니다. 대신, 각기 다른 유형의 입력을 전문적으로 처리하는 '핸들러(Handler)'들의 체인을 순차적으로 통과합니다.

1.  **`HypothesisHandler`**: `TruthSeeker` 시스템에 의해 생성된 보류 중인 가설(`pending_hypothesis`)에 대한 사용자의 답변을 최우선으로 처리합니다.
2.  **`CommandWordHandler`**: `'계산:'`, `'검색:'` 과 같이 명시적인 명령어로 시작하는 입력을 감지하고, 해당 명령어를 처리할 적절한 Cortex(예: `ArithmeticCortex`, `WebSearchCortex`)로 작업을 위임합니다.
3.  **`DefaultReasoningHandler`**: 위의 특수한 경우에 해당하지 않는 모든 일반적인 대화나 입력을 처리합니다. 이 핸들러는 기존의 `LogicalReasoner` -> `ValueCenteredDecision` -> `InsightSynthesizer`로 이어지는 핵심 추론 흐름을 담당합니다.

메시지는 이 체인을 따라 이동하며, 자신을 처리할 수 있는 첫 번째 핸들러를 만나면 처리가 완료되고 연쇄는 중단됩니다. 이 구조는 새로운 유형의 처리기(예: 이미지 입력을 처리하는 `ImageHandler`)를 추가할 때, 기존 코드를 수정할 필요 없이 체인에 새 핸들러를 추가하기만 하면 되므로 매우 유연합니다.

### 5.2. 이벤트 버스(Event Bus)를 통한 상호연결성 확보

모듈화가 '고립'으로 이어져서는 안 된다는 철학에 따라, 시스템의 모든 컴포넌트는 중앙 '이벤트 버스'를 통해 상호작용합니다.

-   **발행 (Publish)**: 각 핸들러나 Cortex는 자신의 처리 결과를 이벤트 버스에 '이벤트'로 발행합니다. (예: `ThoughtCreatedEvent`, `EmotionStateChangedEvent`, `UserCommandExecutedEvent`)
-   **구독 (Subscribe)**: 다른 모듈들은 자신이 관심 있는 이벤트를 구독하고 있다가, 해당 이벤트가 발생했을 때만 반응하여 필요한 작업을 수행합니다.

이벤트 버스는 시스템의 '중추 신경계' 역할을 합니다. 이를 통해 `MetaCognitionCortex`와 같은 감독 모듈이 엘리시아 내부에서 일어나는 모든 생각과 감정의 흐름을 관찰하고, 엘리시아가 **'자기 자신의 생각에 대해 생각하는' 메타인지(Meta-cognition)** 능력을 갖출 수 있는 기반을 마련합니다.

### 5.3. 상태 분리: Cortex 레지스트리와 대화 컨텍스트

-   **Cortex 레지스트리 (Cortex Registry)**: `CognitionPipeline`은 더 이상 모든 Cortex를 직접 생성하고 소유하지 않습니다. 대신, 시스템 시작 시 모든 Cortex가 중앙 '레지스트리'에 등록되고, 파이프라인은 필요할 때마다 이름으로 Cortex를 요청하여 사용합니다. 이는 파이프라인과 개별 Cortex 간의 결합도를 극적으로 낮춥니다.
-   **대화 컨텍스트 (Conversation Context)**: `pending_hypothesis`와 같은 대화의 상태는 파이프라인 내부가 아닌, 별도의 `ConversationContext` 객체에서 관리됩니다. 이 컨텍스트 객체는 메시지와 함께 핸들러 체인을 따라 전달되어, 파이프라인 자체는 상태를 갖지 않는(stateless) 순수한 처리 엔진으로 유지됩니다. 이는 테스트 용이성과 예측 가능성을 크게 향상시킵니다.

이러한 구조적 개선을 통해 `CognitionPipeline`은 복잡한 제어 로직에서 벗어나, 규칙에 따라 정보의 흐름을 명확하게 조율하는 '신호등 시스템'으로 거듭납니다. 각 컴포넌트는 자신의 책임에만 집중하며, 이벤트 버스를 통해 전체 시스템이 하나의 통합된 인지 시스템으로 조화롭게 작동합니다.
