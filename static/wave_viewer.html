<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Elysia Wave Universe | ÏóòÎ¶¨ÏãúÏïÑ ÌååÎèô Ïö∞Ï£º</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Consolas', 'Monaco', monospace;
            background: #000;
            color: #fff;
            overflow: hidden;
        }
        
        #canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }
        
        #info {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            border: 2px solid rgba(82, 255, 168, 0.3);
            font-size: 12px;
            line-height: 1.6;
            max-width: 300px;
        }
        
        #info h2 {
            color: #52ffa8;
            margin-bottom: 10px;
            font-size: 16px;
        }
        
        #info .spirit {
            margin: 5px 0;
        }
        
        #info .bar {
            display: inline-block;
            width: 100px;
            height: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            overflow: hidden;
            vertical-align: middle;
            margin-left: 10px;
        }
        
        #info .bar-fill {
            height: 100%;
            transition: width 0.1s ease-out;
        }
        
        .fire { background: linear-gradient(90deg, #ff4500, #ff8c00); }
        .water { background: linear-gradient(90deg, #1e90ff, #87ceeb); }
        .earth { background: linear-gradient(90deg, #8b4513, #d2691e); }
        .air { background: linear-gradient(90deg, #f0f8ff, #e0ffff); }
        .light { background: linear-gradient(90deg, #ffd700, #ffff00); }
        .dark { background: linear-gradient(90deg, #4b0082, #8b008b); }
        .aether { background: linear-gradient(90deg, #ff1493, #ff69b4); }
        
        #status {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 15px;
            border-radius: 10px;
            border: 2px solid rgba(82, 255, 168, 0.3);
            font-size: 12px;
        }
        
        .connected { color: #52ffa8; }
        .disconnected { color: #ff4500; }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    
    <div id="info">
        <h2>üåä Elysia Wave Universe</h2>
        <div class="spirit">üî• Fire: <span class="bar"><span class="bar-fill fire" id="bar-fire"></span></span></div>
        <div class="spirit">üíß Water: <span class="bar"><span class="bar-fill water" id="bar-water"></span></span></div>
        <div class="spirit">üåç Earth: <span class="bar"><span class="bar-fill earth" id="bar-earth"></span></span></div>
        <div class="spirit">üí® Air: <span class="bar"><span class="bar-fill air" id="bar-air"></span></span></div>
        <div class="spirit">‚ú® Light: <span class="bar"><span class="bar-fill light" id="bar-light"></span></span></div>
        <div class="spirit">üåë Dark: <span class="bar"><span class="bar-fill dark" id="bar-dark"></span></span></div>
        <div class="spirit">üîÆ Aether: <span class="bar"><span class="bar-fill aether" id="bar-aether"></span></span></div>
    </div>
    
    <div id="status">
        <span id="connection-status" class="disconnected">‚óè Connecting...</span>
    </div>

    <script>
        // ============================================
        // WebSocket Connection
        // ============================================
        let ws = null;
        let waveState = {
            fire: 0.5, water: 0.5, earth: 0.5, air: 0.5,
            light: 0.5, dark: 0.5, aether: 0.5,
            dimension_0d: 0, dimension_1d: 0, dimension_2d: 0, dimension_3d: 0,
            cpu_heat: 0, memory_load: 0, file_count: 0,
            time: 0
        };
        
        function connectWebSocket() {
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsUrl = `${protocol}//${window.location.host}/wave-stream`;
            
            ws = new WebSocket(wsUrl);
            
            ws.onopen = () => {
                console.log('üîå Connected to wave stream');
                document.getElementById('connection-status').textContent = '‚óè Connected';
                document.getElementById('connection-status').className = 'connected';
            };
            
            ws.onmessage = (event) => {
                waveState = JSON.parse(event.data);
                updateUI();
            };
            
            ws.onerror = (error) => {
                console.error('WebSocket error:', error);
            };
            
            ws.onclose = () => {
                console.log('üîå Disconnected from wave stream');
                document.getElementById('connection-status').textContent = '‚óè Disconnected';
                document.getElementById('connection-status').className = 'disconnected';
                
                // Auto reconnect after 2 seconds
                setTimeout(connectWebSocket, 2000);
            };
        }
        
        function updateUI() {
            // Update spirit bars
            document.getElementById('bar-fire').style.width = (waveState.fire * 100) + '%';
            document.getElementById('bar-water').style.width = (waveState.water * 100) + '%';
            document.getElementById('bar-earth').style.width = (waveState.earth * 100) + '%';
            document.getElementById('bar-air').style.width = (waveState.air * 100) + '%';
            document.getElementById('bar-light').style.width = (waveState.light * 100) + '%';
            document.getElementById('bar-dark').style.width = (waveState.dark * 100) + '%';
            document.getElementById('bar-aether').style.width = (waveState.aether * 100) + '%';
        }
        
        // ============================================
        // WebGL Renderer
        // ============================================
        const canvas = document.getElementById('canvas');
        const gl = canvas.getContext('webgl2') || canvas.getContext('webgl');
        
        if (!gl) {
            alert('WebGL not supported!');
        }
        
        // Resize canvas
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            gl.viewport(0, 0, canvas.width, canvas.height);
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();
        
        // ============================================
        // Wave Fragment Shader (THE MAGIC!)
        // ============================================
        const vertexShaderSource = `
            attribute vec2 position;
            void main() {
                gl_Position = vec4(position, 0.0, 1.0);
            }
        `;
        
        const fragmentShaderSource = `
            precision highp float;
            
            uniform vec2 resolution;
            uniform float time;
            
            // 7 Spirits Energy
            uniform float fire;
            uniform float water;
            uniform float earth;
            uniform float air;
            uniform float light;
            uniform float dark;
            uniform float aether;
            
            // Consciousness Dimensions
            uniform float dim0d;
            uniform float dim1d;
            uniform float dim2d;
            uniform float dim3d;
            
            // Wave Function: SDF Sphere
            float sdSphere(vec3 p, float r) {
                return length(p) - r;
            }
            
            // Wave Interference
            float waveField(vec3 p) {
                float d = 0.0;
                
                // 7 Spirits as wave sources
                d += sin(length(p - vec3(1.0, 0.0, 0.0)) * 10.0 - time * 2.0) * fire * 0.3;
                d += sin(length(p - vec3(-1.0, 0.0, 0.0)) * 8.0 - time * 1.5) * water * 0.3;
                d += sin(length(p - vec3(0.0, 1.0, 0.0)) * 6.0 - time * 1.0) * earth * 0.2;
                d += sin(length(p - vec3(0.0, -1.0, 0.0)) * 12.0 - time * 2.5) * air * 0.4;
                d += sin(length(p - vec3(0.7, 0.7, 0.0)) * 15.0 - time * 3.0) * light * 0.35;
                d += sin(length(p - vec3(-0.7, -0.7, 0.0)) * 5.0 - time * 0.5) * dark * 0.2;
                d += sin(length(p) * 20.0 - time * 4.0) * aether * 0.4;
                
                return d;
            }
            
            // Ray Marching
            vec3 rayMarch(vec3 ro, vec3 rd) {
                float t = 0.0;
                vec3 col = vec3(0.0);
                
                for(int i = 0; i < 64; i++) {
                    vec3 p = ro + rd * t;
                    float field = waveField(p);
                    
                    // Accumulate color based on wave field
                    float intensity = abs(field);
                    
                    // Spirit colors
                    col += vec3(1.0, 0.3, 0.1) * fire * intensity * 0.1;
                    col += vec3(0.1, 0.5, 1.0) * water * intensity * 0.1;
                    col += vec3(0.5, 0.3, 0.1) * earth * intensity * 0.05;
                    col += vec3(0.9, 0.9, 1.0) * air * intensity * 0.15;
                    col += vec3(1.0, 1.0, 0.5) * light * intensity * 0.12;
                    col += vec3(0.3, 0.1, 0.5) * dark * intensity * 0.08;
                    col += vec3(1.0, 0.4, 0.8) * aether * intensity * 0.15;
                    
                    t += 0.02;
                    if(t > 3.0) break;
                }
                
                return col;
            }
            
            void main() {
                vec2 uv = (gl_FragCoord.xy - 0.5 * resolution) / resolution.y;
                
                // Camera
                vec3 ro = vec3(0.0, 0.0, -2.0);
                vec3 rd = normalize(vec3(uv, 1.0));
                
                // Rotate camera based on dimensions
                float angle = time * 0.2 + dim0d;
                ro.xz = mat2(cos(angle), -sin(angle), sin(angle), cos(angle)) * ro.xz;
                rd.xz = mat2(cos(angle), -sin(angle), sin(angle), cos(angle)) * rd.xz;
                
                // Render
                vec3 col = rayMarch(ro, rd);
                
                // Dimension overlay
                col += vec3(0.2, 0.1, 0.3) * dim0d * 0.1;
                col += vec3(0.1, 0.3, 0.2) * dim1d * 0.1;
                col += vec3(0.3, 0.2, 0.1) * dim2d * 0.1;
                col += vec3(0.2, 0.3, 0.1) * dim3d * 0.1;
                
                gl_FragColor = vec4(col, 1.0);
            }
        `;
        
        // Compile shaders
        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('Shader compile error:', gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            
            return shader;
        }
        
        const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
        const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
        
        // Link program
        const program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);
        
        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
            console.error('Program link error:', gl.getProgramInfoLog(program));
        }
        
        gl.useProgram(program);
        
        // Setup geometry (fullscreen quad)
        const positions = new Float32Array([
            -1, -1,
             1, -1,
            -1,  1,
             1,  1
        ]);
        
        const positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);
        
        const positionLocation = gl.getAttribLocation(program, 'position');
        gl.enableVertexAttribArray(positionLocation);
        gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);
        
        // Get uniform locations
        const uniforms = {
            resolution: gl.getUniformLocation(program, 'resolution'),
            time: gl.getUniformLocation(program, 'time'),
            fire: gl.getUniformLocation(program, 'fire'),
            water: gl.getUniformLocation(program, 'water'),
            earth: gl.getUniformLocation(program, 'earth'),
            air: gl.getUniformLocation(program, 'air'),
            light: gl.getUniformLocation(program, 'light'),
            dark: gl.getUniformLocation(program, 'dark'),
            aether: gl.getUniformLocation(program, 'aether'),
            dim0d: gl.getUniformLocation(program, 'dim0d'),
            dim1d: gl.getUniformLocation(program, 'dim1d'),
            dim2d: gl.getUniformLocation(program, 'dim2d'),
            dim3d: gl.getUniformLocation(program, 'dim3d')
        };
        
        // ============================================
        // Render Loop
        // ============================================
        let startTime = Date.now();
        
        function render() {
            const currentTime = (Date.now() - startTime) / 1000;
            
            // Set uniforms
            gl.uniform2f(uniforms.resolution, canvas.width, canvas.height);
            gl.uniform1f(uniforms.time, currentTime);
            
            // Wave state
            gl.uniform1f(uniforms.fire, waveState.fire);
            gl.uniform1f(uniforms.water, waveState.water);
            gl.uniform1f(uniforms.earth, waveState.earth);
            gl.uniform1f(uniforms.air, waveState.air);
            gl.uniform1f(uniforms.light, waveState.light);
            gl.uniform1f(uniforms.dark, waveState.dark);
            gl.uniform1f(uniforms.aether, waveState.aether);
            
            gl.uniform1f(uniforms.dim0d, waveState.dimension_0d);
            gl.uniform1f(uniforms.dim1d, waveState.dimension_1d);
            gl.uniform1f(uniforms.dim2d, waveState.dimension_2d);
            gl.uniform1f(uniforms.dim3d, waveState.dimension_3d);
            
            // Draw
            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
            
            requestAnimationFrame(render);
        }
        
        // Start
        connectWebSocket();
        render();
        
        console.log('üåä Elysia Wave Universe initialized');
        console.log('"Ïó∞ÏÇ∞ÌïòÏßÄ ÎßàÏÑ∏Ïöî. ÌùêÎ•¥Í≤å ÎëêÏÑ∏Ïöî."');
    </script>
</body>
</html>
