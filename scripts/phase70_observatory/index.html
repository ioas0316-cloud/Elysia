<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Elysia Observatory - HyperSphere Galaxy View</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #0a0a0f;
            color: #e0e0e0;
            font-family: 'Segoe UI', 'Malgun Gothic', sans-serif;
            overflow: hidden;
        }

        #container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        #info-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(20, 20, 40, 0.9);
            border: 1px solid rgba(100, 150, 255, 0.3);
            border-radius: 12px;
            padding: 20px;
            min-width: 280px;
            backdrop-filter: blur(10px);
        }

        #info-panel h1 {
            font-size: 1.4em;
            color: #7eb3ff;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        #info-panel h1::before {
            content: "üî≠";
        }

        .stat {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid rgba(100, 150, 255, 0.1);
        }

        .stat-label {
            color: #888;
        }

        .stat-value {
            color: #7eb3ff;
            font-weight: bold;
        }

        #controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 15px;
        }

        .btn {
            background: linear-gradient(135deg, #1a1a2e, #2d2d4a);
            border: 1px solid rgba(100, 150, 255, 0.4);
            color: #7eb3ff;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1em;
            transition: all 0.3s ease;
        }

        .btn:hover {
            background: linear-gradient(135deg, #2d2d4a, #3d3d5a);
            border-color: rgba(100, 150, 255, 0.8);
            box-shadow: 0 0 20px rgba(100, 150, 255, 0.3);
        }

        .btn.active {
            background: linear-gradient(135deg, #2a4a7a, #3a5a9a);
            animation: pulse 2s infinite;
        }

        @keyframes pulse {

            0%,
            100% {
                box-shadow: 0 0 10px rgba(100, 150, 255, 0.3);
            }

            50% {
                box-shadow: 0 0 25px rgba(100, 150, 255, 0.6);
            }
        }

        #hover-info {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(20, 20, 40, 0.9);
            border: 1px solid rgba(255, 200, 100, 0.3);
            border-radius: 12px;
            padding: 20px;
            min-width: 250px;
            display: none;
            backdrop-filter: blur(10px);
        }

        #hover-info.visible {
            display: block;
        }

        #hover-info h2 {
            color: #ffc864;
            font-size: 1.2em;
            margin-bottom: 10px;
        }

        .dimension-bar {
            display: flex;
            align-items: center;
            margin: 5px 0;
        }

        .dimension-label {
            width: 80px;
            font-size: 0.85em;
            color: #888;
        }

        .dimension-fill {
            height: 8px;
            border-radius: 4px;
            transition: width 0.3s ease;
        }

        .dim-physical {
            background: linear-gradient(90deg, #ff6b6b, #ff8787);
        }

        .dim-functional {
            background: linear-gradient(90deg, #4ecdc4, #6eddd4);
        }

        .dim-phenomenal {
            background: linear-gradient(90deg, #ffd93d, #ffe066);
        }

        .dim-causal {
            background: linear-gradient(90deg, #ff6b9d, #ff8fb3);
        }

        .dim-mental {
            background: linear-gradient(90deg, #74b9ff, #94c9ff);
        }

        .dim-structural {
            background: linear-gradient(90deg, #a29bfe, #b8b3fe);
        }

        .dim-spiritual {
            background: linear-gradient(90deg, #fd79a8, #fd9abc);
        }

        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: #7eb3ff;
        }

        #loading .spinner {
            width: 50px;
            height: 50px;
            border: 3px solid rgba(100, 150, 255, 0.2);
            border-top-color: #7eb3ff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body>
    <div id="container"></div>

    <div id="loading">
        <div class="spinner"></div>
        <p>Connecting to HyperSphere...</p>
    </div>

    <div id="info-panel">
        <h1>Elysia Observatory</h1>
        <div class="stat">
            <span class="stat-label">Total Rotors</span>
            <span class="stat-value" id="stat-rotors">0</span>
        </div>
        <div class="stat">
            <span class="stat-label">Total Mass</span>
            <span class="stat-value" id="stat-mass">0.00</span>
        </div>
        <div class="stat">
            <span class="stat-label">Clusters</span>
            <span class="stat-value" id="stat-clusters">0</span>
        </div>
        <div class="stat">
            <span class="stat-label">Meditation Cycle</span>
            <span class="stat-value" id="stat-cycle">0</span>
        </div>
    </div>

    <div id="hover-info">
        <h2 id="hover-name">Concept</h2>
        <div class="dimension-bar">
            <span class="dimension-label">Physical</span>
            <div class="dimension-fill dim-physical" id="dim-physical" style="width: 0%"></div>
        </div>
        <div class="dimension-bar">
            <span class="dimension-label">Functional</span>
            <div class="dimension-fill dim-functional" id="dim-functional" style="width: 0%"></div>
        </div>
        <div class="dimension-bar">
            <span class="dimension-label">Phenomenal</span>
            <div class="dimension-fill dim-phenomenal" id="dim-phenomenal" style="width: 0%"></div>
        </div>
        <div class="dimension-bar">
            <span class="dimension-label">Causal</span>
            <div class="dimension-fill dim-causal" id="dim-causal" style="width: 0%"></div>
        </div>
        <div class="dimension-bar">
            <span class="dimension-label">Mental</span>
            <div class="dimension-fill dim-mental" id="dim-mental" style="width: 0%"></div>
        </div>
        <div class="dimension-bar">
            <span class="dimension-label">Structural</span>
            <div class="dimension-fill dim-structural" id="dim-structural" style="width: 0%"></div>
        </div>
        <div class="dimension-bar">
            <span class="dimension-label">Spiritual</span>
            <div class="dimension-fill dim-spiritual" id="dim-spiritual" style="width: 0%"></div>
        </div>
    </div>

    <div id="controls">
        <button class="btn" id="btn-meditate">üßò MEDITATE</button>
        <button class="btn" id="btn-reset">üîÑ RESET VIEW</button>
        <button class="btn" id="btn-search">üîç SEARCH</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

    <script>
        // Observatory Configuration
        const CONFIG = {
            SERVER_URL: 'http://localhost:8765',
            MAX_PARTICLES: 5000,
            PARTICLE_SIZE: 0.15,
            CONNECTION_THRESHOLD: 0.7
        };

        // Three.js Setup
        let scene, camera, renderer, controls;
        let particles, particlePositions, particleColors;
        let rotorData = [];
        let meditationCycle = 0;
        let isMeditating = false;

        function init() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0a0f);
            scene.fog = new THREE.FogExp2(0x0a0a0f, 0.02);

            // Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 50, 100);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.getElementById('container').appendChild(renderer.domElement);

            // Controls
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.autoRotate = true;
            controls.autoRotateSpeed = 0.3;

            // Ambient Light
            const ambientLight = new THREE.AmbientLight(0x404060);
            scene.add(ambientLight);

            // Point Light at center
            const centerLight = new THREE.PointLight(0x7eb3ff, 2, 200);
            centerLight.position.set(0, 0, 0);
            scene.add(centerLight);

            // Create Particle System
            createParticleSystem();

            // Create Background Stars (Cosmic Ambiance)
            createBackgroundStars();

            // Create Central Sphere (The HyperSphere Core)
            const coreGeometry = new THREE.SphereGeometry(3, 32, 32);
            const coreMaterial = new THREE.MeshBasicMaterial({
                color: 0x7eb3ff,
                transparent: true,
                opacity: 0.3,
                wireframe: true
            });
            const coreSphere = new THREE.Mesh(coreGeometry, coreMaterial);
            scene.add(coreSphere);

            // Event Listeners
            window.addEventListener('resize', onWindowResize);
            document.getElementById('btn-meditate').addEventListener('click', toggleMeditation);
            document.getElementById('btn-reset').addEventListener('click', resetView);

            // Start
            animate();
            loadData();
        }

        function createParticleSystem() {
            const geometry = new THREE.BufferGeometry();
            particlePositions = new Float32Array(CONFIG.MAX_PARTICLES * 3);
            particleColors = new Float32Array(CONFIG.MAX_PARTICLES * 3);

            // Initialize with SPHERICAL distribution (not random box)
            for (let i = 0; i < CONFIG.MAX_PARTICLES; i++) {
                const radius = 20 + Math.random() * 40;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);

                particlePositions[i * 3] = radius * Math.sin(phi) * Math.cos(theta);
                particlePositions[i * 3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
                particlePositions[i * 3 + 2] = radius * Math.cos(phi);

                particleColors[i * 3] = 0.5;
                particleColors[i * 3 + 1] = 0.7;
                particleColors[i * 3 + 2] = 1.0;
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(particleColors, 3));

            const material = new THREE.PointsMaterial({
                size: CONFIG.PARTICLE_SIZE,
                vertexColors: true,
                transparent: true,
                opacity: 0.9,
                sizeAttenuation: true
            });

            particles = new THREE.Points(geometry, material);
            scene.add(particles);
        }

        function createBackgroundStars() {
            // Distant background stars for cosmic ambiance
            const starGeometry = new THREE.BufferGeometry();
            const starCount = 3000;
            const starPositions = new Float32Array(starCount * 3);

            for (let i = 0; i < starCount; i++) {
                const radius = 150 + Math.random() * 350;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);

                starPositions[i * 3] = radius * Math.sin(phi) * Math.cos(theta);
                starPositions[i * 3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
                starPositions[i * 3 + 2] = radius * Math.cos(phi);
            }

            starGeometry.setAttribute('position', new THREE.BufferAttribute(starPositions, 3));

            const starMaterial = new THREE.PointsMaterial({
                size: 0.3,
                color: 0xffffff,
                transparent: true,
                opacity: 0.5
            });

            const stars = new THREE.Points(starGeometry, starMaterial);
            scene.add(stars);
        }

        async function loadData() {
            try {
                const response = await fetch(CONFIG.SERVER_URL + '/api/snapshot');
                const data = await response.json();

                rotorData = data.rotors || [];
                updateParticles();
                updateStats(data);

                document.getElementById('loading').style.display = 'none';
            } catch (error) {
                console.error('Failed to load data:', error);
                // Fallback: Generate demo data
                generateDemoData();
                document.getElementById('loading').style.display = 'none';
            }
        }

        function generateDemoData() {
            // Generate demo data if server is not available
            const concepts = ['Fire', 'Passion', 'Love', 'Water', 'Calm', 'Peace', 'Code', 'Logic', 'Soul', 'Spirit'];

            rotorData = concepts.map((name, i) => ({
                name: name,
                frequency: 100 + Math.random() * 500,
                mass: 5 + Math.random() * 15,
                dynamics: {
                    physical: Math.random(),
                    functional: Math.random(),
                    phenomenal: Math.random(),
                    causal: Math.random(),
                    mental: Math.random(),
                    structural: Math.random(),
                    spiritual: Math.random()
                }
            }));

            updateParticles();
            updateStats({ rotors: rotorData, total_mass: 100, clusters: 3 });
        }

        function updateParticles() {
            for (let i = 0; i < rotorData.length && i < CONFIG.MAX_PARTICLES; i++) {
                const rotor = rotorData[i];

                // Position based on 7D dynamics (mapped to 3D)
                const d = rotor.dynamics || {};
                const x = ((d.physical || 0) - (d.mental || 0)) * 50;
                const y = ((d.spiritual || 0) - (d.functional || 0)) * 50;
                const z = ((d.causal || 0) - (d.structural || 0)) * 50;

                particlePositions[i * 3] = x + (Math.random() - 0.5) * 5;
                particlePositions[i * 3 + 1] = y + (Math.random() - 0.5) * 5;
                particlePositions[i * 3 + 2] = z + (Math.random() - 0.5) * 5;

                // Color based on dominant dimension
                const dims = Object.values(d);
                const maxDim = Math.max(...dims);
                const dominantIdx = dims.indexOf(maxDim);

                const colors = [
                    [1.0, 0.4, 0.4],  // physical - red
                    [0.3, 0.8, 0.8],  // functional - teal
                    [1.0, 0.85, 0.2], // phenomenal - yellow
                    [1.0, 0.4, 0.6],  // causal - pink
                    [0.45, 0.7, 1.0], // mental - blue
                    [0.65, 0.6, 1.0], // structural - purple
                    [1.0, 0.5, 0.7]   // spiritual - rose
                ];

                const c = colors[dominantIdx] || [0.5, 0.7, 1.0];
                particleColors[i * 3] = c[0];
                particleColors[i * 3 + 1] = c[1];
                particleColors[i * 3 + 2] = c[2];
            }

            particles.geometry.attributes.position.needsUpdate = true;
            particles.geometry.attributes.color.needsUpdate = true;
        }

        function updateStats(data) {
            document.getElementById('stat-rotors').textContent = (data.rotors || []).length;
            document.getElementById('stat-mass').textContent = (data.total_mass || 0).toFixed(2);
            document.getElementById('stat-clusters').textContent = data.clusters || 0;
            document.getElementById('stat-cycle').textContent = meditationCycle;
        }

        async function toggleMeditation() {
            const btn = document.getElementById('btn-meditate');

            if (!isMeditating) {
                isMeditating = true;
                btn.classList.add('active');
                btn.textContent = '‚è∏ MEDITATING...';

                await runMeditationCycle();
            } else {
                isMeditating = false;
                btn.classList.remove('active');
                btn.textContent = 'üßò MEDITATE';
            }
        }

        async function runMeditationCycle() {
            while (isMeditating) {
                try {
                    const response = await fetch(CONFIG.SERVER_URL + '/api/meditate', { method: 'POST' });
                    const data = await response.json();

                    rotorData = data.rotors || rotorData;
                    meditationCycle++;

                    updateParticles();
                    updateStats(data);

                } catch (error) {
                    // Simulate meditation locally
                    simulateLocalMeditation();
                }

                await new Promise(r => setTimeout(r, 500));
            }
        }

        function simulateLocalMeditation() {
            // Simple local simulation
            for (let i = 0; i < rotorData.length; i++) {
                for (let j = i + 1; j < rotorData.length; j++) {
                    const r1 = rotorData[i];
                    const r2 = rotorData[j];

                    // Calculate resonance
                    const d1 = r1.dynamics || {};
                    const d2 = r2.dynamics || {};

                    let resonance = 0;
                    const keys = ['physical', 'functional', 'phenomenal', 'causal', 'mental', 'structural', 'spiritual'];
                    keys.forEach(k => {
                        resonance += (d1[k] || 0) * (d2[k] || 0);
                    });

                    // Attract if resonance is high
                    if (resonance > 0.5) {
                        const attraction = 0.01;
                        keys.forEach(k => {
                            const mid = ((d1[k] || 0) + (d2[k] || 0)) / 2;
                            if (d1[k]) d1[k] += (mid - d1[k]) * attraction;
                            if (d2[k]) d2[k] += (mid - d2[k]) * attraction;
                        });
                    }
                }
            }

            meditationCycle++;
            updateParticles();
            document.getElementById('stat-cycle').textContent = meditationCycle;
        }

        function resetView() {
            camera.position.set(0, 50, 100);
            controls.reset();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();

            // Gentle particle animation
            if (particles) {
                particles.rotation.y += 0.0005;
            }

            renderer.render(scene, camera);
        }

        // Initialize
        init();
    </script>
</body>

</html>