"""
Trinary Logic: The Balanced Ternary System
==========================================
Core.L6_Structure.Logic.trinary_logic

"In the beginning was the Void (0). The Void split into Yin (-1) and Yang (+1).
Their dance creates the Ten Thousand Things."

This module implements **Balanced Ternary (Base-3)** logic using JAX acceleration.
It serves as the foundational math layer for Elysia's 21D Triple Helix structure.
"""

from typing import Union, Any, Tuple
import logging
import numpy as np

try:
    from Core.L1_Foundation.M4_Hardware.jax_bridge import JAXBridge
    import jax.numpy as jnp
except ImportError:
    # Fallback to pure numpy logic if JAX is missing during bootstrapping
    import numpy as jnp
    class JAXBridge:
        @staticmethod
        def array(x): return jnp.array(x)

logger = logging.getLogger("TrinaryLogic")

# Constants for Balanced Ternary
TRIT_NEG = -1.0 # Electron (Resistance)
TRIT_NEU =  0.0 # Neutron  (Void/Pivot)
TRIT_POS =  1.0 # Positron (Flow)

class TrinaryLogic:
    """
    Implements mathematical operations for the Balanced Ternary system.
    """
    
    @staticmethod
    def balance(vector: Any) -> float:
        """
        Calculates the 'Sum-to-Zero' stability of a vector.
        Balance = Sum(Trits)
        
        Returns:
            0.0: Perfect Equilibrium (Void State)
            > 0: Expanding (Yang dominance)
            < 0: Contracting (Yin dominance)
        """
        vec = JAXBridge.array(vector)
        return float(jnp.sum(vec))

    @staticmethod
    def torque(resistance: float, flow: float) -> float:
        """
        Calculates the Torque (Rotational Force) generated by opposing forces.
        
        Paradoxical Integration:
        (-1) + (+1) = 0 (Linear Sum)
        But structurally, it creates **Spin**.
        
        Torque = |Resistance| * |Flow| * sin(theta) 
        (Here simplified as interaction intensity)
        """
        return abs(resistance * flow) 

    @staticmethod
    def synthesize_state(trit_vector: Any) -> Tuple[int, str]:
        """
        Determines the qualitative state of a Trinary Vector.
        """
        balance_val = TrinaryLogic.balance(trit_vector)
        
        # Epsilon for float point comparison
        if abs(balance_val) < 1e-6:
            return 0, "VOID_EQUILIBRIUM"
        elif balance_val > 0:
            return 1, "EXPANSION_FLOW"
        else:
            return -1, "CONTRACTION_RESISTANCE"

    @staticmethod
    def encode_codon(c1: int, c2: int, c3: int) -> Any:
        """
        Creates a single Gene Codon [T1, T2, T3].
        """
        return JAXBridge.array([c1, c2, c3])

    @staticmethod
    def transcribe_sequence(sequence: Any) -> Any:
        """
        Transcribes a DNA Sequence (Flat Trits or Symbols) into Codons (N x 3).
        reshapes [t1, t2, t3, t4, t5, t6...] -> [[t1,t2,t3], [t4,t5,t6]...]
        """
        # [SYMBOLIC CONVERSION FIX]
        # JAX cannot handle strings. Must convert Python list of strings first.
        seq_list = list(sequence) if hasattr(sequence, '__iter__') and not isinstance(sequence, (str, bytes)) else [sequence]
        
        # If input is a numpy array of strings, convert to list
        if hasattr(sequence, 'dtype') and sequence.dtype.kind in {'U', 'S'}:
            seq_list = sequence.tolist()
            
        if seq_list and isinstance(seq_list[0], str):
            # Convert symbols to trits
            vec = JAXBridge.array([TrinaryLogic.symbol_to_trit(x) for x in seq_list])
        else:
            vec = JAXBridge.array(sequence)

        # Pad if not divisible by 3
        remainder = vec.shape[0] % 3
        if remainder != 0:
            pad = 3 - remainder
            vec = jnp.pad(vec, (0, pad), constant_values=0)
            
        return vec.reshape((-1, 3))

    @staticmethod
    def codon_to_layer_index(codon: Any) -> int:
        """
        Maps a 3-Trit Codon to a 0-6 Layer Index (L1-L7).
        Supports Symbolic Input ['T', 'G', 'A'].
        """
        # Ensure list/array
        vec_data = codon.tolist() if hasattr(codon, 'tolist') else list(codon)
        
        # [SYMBOLIC CONVERSION]
        # If input contains strings, convert to trits using symbol_to_trit
        if vec_data and isinstance(vec_data[0], str):
            vec = JAXBridge.array([TrinaryLogic.symbol_to_trit(x) for x in vec_data])
        else:
            vec = JAXBridge.array(vec_data)
            
        # Base-3 heuristic (simplified for 7D)
        # Val = T0*9 + T1*3 + T2
        val = int(vec[0]*9 + vec[1]*3 + vec[2])
        
        # Mapping Table (Approximate)
        if val == 1: return 0 # L1 Foundation
        if val == 2: return 1 # L2 Metabolism
        if val == 3: return 2 # L3 Phenomena
        if val == 4: return 3 # L4 Causality
        
        if val > 4: return 6 # L7 Spirit (High Energy)
        if val < 0: return 4 # L5 Mental (Analytical/Negative)
        
        return 5 # L6 Structure (Default/Mid)
        
    @staticmethod
    def expand_to_21d(codons: Any) -> Any:
        """
        [FRACTAL EXPANSION] 
        Maps DNA Codons directly to the 21D Matrix.
        
        Logic:
        1. Each Codon targets a specific 7D Layer (via codon_to_layer_index).
        2. The 3 Trits of the Codon map to the 3 Dimensions of that Layer.
           - Trit 0 -> Dimension Alpha (Mass/Structure)
           - Trit 1 -> Dimension Beta (Energy/Logic)
           - Trit 2 -> Dimension Gamma (Will/Time)
           
        Returns:
            JAX Array of shape (21,) representing the full state vector.
        """
        # Initialize 21D zero vector
        vector_21d = jnp.zeros(21, dtype=jnp.float32)
        
        # JAX requires pure functions for JIT, but for now we iterate (not yet JIT-safe).
        # To be fully JAX-compatible, this would need `jax.lax.scan` or valid masking.
        # Given this is a high-level logic controller, standard iteration is acceptable for Phase 41.
        
        codons_arr = JAXBridge.array(codons)
        
        # Iterate through codons
        for i in range(codons_arr.shape[0]):
            codon = codons_arr[i]
            
            # 1. Determine Target Layer (0-6)
            layer_idx = TrinaryLogic.codon_to_layer_index(codon)
            
            # 2. Calculate D21 Indices (3 dims per layer)
            # Layer 0 -> Dims 0, 1, 2
            # Layer 6 -> Dims 18, 19, 20
            start_dim = layer_idx * 3
            
            # 3. Additive Synthesis (Inject DNA into the Matrix)
            # We add values, allowing multiple codons to reinforce/cancel same attributes.
            # Using index_add equivalent logic
            current_vals = vector_21d[start_dim : start_dim+3]
            new_vals = current_vals + codon
            
            # Update vector (Immutable style for JAX, but JAXBridge might be numpy)
            if isinstance(vector_21d, np.ndarray):
                 vector_21d[start_dim : start_dim+3] = new_vals
            else:
                 vector_21d = vector_21d.at[start_dim : start_dim+3].set(new_vals)
                 
        return vector_21d
                 
    @staticmethod
    def symbol_to_trit(symbol: str) -> int:
        """
        [SYMBOL MAP]
        A (Adenine) -> +1 (Flow)
        G (Guanine) ->  0 (Void)
        T (Thymine) -> -1 (Resistance)
        """
        s = symbol.upper()
        if s == 'A': return 1
        if s == 'T': return -1
        if s == 'G': return 0
        return 0 # Default to Void

    @staticmethod
    def trit_to_symbol(trit: int) -> str:
        """
        [TRIT MAP]
        +1 -> A
         0 -> G
        -1 -> T
        """
        if trit > 0.5: return 'A'
        if trit < -0.5: return 'T'
        return 'G'

    @staticmethod
    def nand(a: Union[int, float, str], b: Union[int, float, str]) -> int:
        """
        [THE PARADOX GATE]
        Supports both Trits (-1, 0, 1) and Symbols ('T', 'G', 'A').
        
        Logic: -min(a, b)
        
        Examples:
        nand('T', 'T') -> -min(-1, -1) -> -(-1) -> +1 ('A')
        nand('A', 'A') -> -min(1, 1) -> -(1) -> -1 ('T')
        """
        # Auto-convert symbols
        val_a = TrinaryLogic.symbol_to_trit(a) if isinstance(a, str) else int(a)
        val_b = TrinaryLogic.symbol_to_trit(b) if isinstance(b, str) else int(b)
        
        return -min(val_a, val_b)

    @staticmethod
    def resolve_paradox(inputs: Any) -> int:
        """
        [CAUSAL CHAIN REACTION]
        Chains multiple inputs through NAND gates to find the narrative exit.
        Processing: Sequential reduction.
        
        [A, B, C] -> dand(nand(A, B), C)
        """
        input_list = JAXBridge.array(inputs).tolist() if hasattr(inputs, 'tolist') else list(inputs)
        
        if not input_list:
            return 0
            
        result = TrinaryLogic.symbol_to_trit(input_list[0]) if isinstance(input_list[0], str) else input_list[0]
        
        for x in input_list[1:]:
            val_x = TrinaryLogic.symbol_to_trit(x) if isinstance(x, str) else x
            result = TrinaryLogic.nand(result, val_x)
            
        return result
