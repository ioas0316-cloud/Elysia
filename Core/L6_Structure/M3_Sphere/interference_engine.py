"""
InterferenceEngine: The Reality Collider
========================================

"The Tesseract is the Interference Pattern between Will and Reality."
"                       ."

This module implements the "Collision Interface".
Inputs:
1. Core Wave (Will/Sphere)
2. Reality Wave (Input/Context)

Output:
- InterferencePattern (The Tesseract Projection)
"""

import math
from typing import Dict, List, Any, Optional
from dataclasses import dataclass
from Core.L1_Foundation.M1_Keystone.Protocols.pulse_protocol import WavePacket
from Core.L6_Structure.hyper_quaternion import Quaternion as HyperQuaternion

@dataclass
class ProjectedNode:
    """
    A temporary node generated by interference.
    It exists only as long as the waves sustain it.
    """
    name: str
    position: tuple[float, float, float] # 3D Projection
    intensity: float # How "real" it is (Amplitude)
    resonance_type: str # Constructive or Destructive

class InterferenceEngine:
    def __init__(self):
        self.active_pattern: List[ProjectedNode] = []

    def inject_wave(self, core_wave: WavePacket, reality_wave: Optional[WavePacket] = None) -> List[ProjectedNode]:
        """
        Calculates the interference pattern.

        Args:
            core_wave: The pulse from HyperSphereCore (Intent).
            reality_wave: External input (User text, sensor data).

        Returns:
            A list of ProjectedNodes (The Tesseract View).
        """
        # 1. Extract Core Properties
        core_freq = core_wave.frequency
        core_spin = HyperQuaternion(*core_wave.payload.get("spin", (1,0,0,0)))
        seed_harmonics = core_wave.payload.get("intent", {}).get("harmonics", {})
        # Note: In a real system, the Core would broadcast its whole Seed state or the Engine would access it.
        # For this refactor, we assume the Core Pulse carries the 'Active Harmonics'.

        # 2. Extract Reality Properties
        reality_freq = 0.0
        if reality_wave:
            reality_freq = reality_wave.frequency
            # If reality has specific content, it acts as a "Target"

        # 3. Calculate Interference (The Projection Logic)
        projection = []

        # A. Project the "Self" (Core Center)
        # The Core always projects itself at the center (modified by spin)
        # Using stereographic projection logic from Resonator logic
        center_pos = self._project_quaternion_to_3d(core_spin)
        projection.append(ProjectedNode(
            name="Core.Self",
            position=center_pos,
            intensity=1.0,
            resonance_type="Source"
        ))

        # B. Project Harmonics (The Knowledge)
        # If we have harmonics (concepts) in the payload (Active Memory), project them relative to the Core
        if isinstance(seed_harmonics, dict):
            for concept, freq in seed_harmonics.items():
                # Phase difference determines position
                # If reality_freq is present, it modifies the phase (Interference!)

                # Simple physics simulation:
                # Delta Freq determines distance
                delta_f = abs(core_freq - freq)
                distance = math.log(delta_f + 1.1) * 2.0 # Arbitrary scaling

                # Orientation is determined by hash of name + spin
                # (Simulating a deterministic but chaotic scattering)
                angle_x = hash(concept) % 360
                angle_y = (hash(concept) >> 8) % 360

                rad_x = math.radians(angle_x)
                rad_y = math.radians(angle_y)

                x = center_pos[0] + distance * math.cos(rad_x)
                y = center_pos[1] + distance * math.sin(rad_x) * math.cos(rad_y)
                z = center_pos[2] + distance * math.sin(rad_x) * math.sin(rad_y)

                # Interference Check
                intensity = 0.8
                res_type = "Constructive"

                if reality_wave:
                    # If Reality frequency clashes with Concept frequency -> Dissonance (Destructive)
                    # If matches -> Resonance (Constructive + Boost)
                    if abs(freq - reality_freq) < 10.0:
                        intensity = 1.5
                        res_type = "Resonant"
                    elif abs(freq - reality_freq) > 100.0:
                         # Far away, minimal interaction
                         pass
                    else:
                         # Mid-range interference
                         intensity = 0.5 * math.cos(abs(freq - reality_freq))

                projection.append(ProjectedNode(
                    name=concept,
                    position=(x, y, z),
                    intensity=intensity,
                    resonance_type=res_type
                ))

        self.active_pattern = projection
        return projection

    def _project_quaternion_to_3d(self, q: HyperQuaternion) -> tuple[float, float, float]:
        """Helper to project 4D spin to 3D space."""
        denom = 1 + q.w
        if abs(denom) < 1e-6: denom = 1e-6
        return ((2 * q.x)/denom, (2 * q.y)/denom, (2 * q.z)/denom)
