"""
Phase Shift Engine (L6 Structure)
=================================
"The Heart of the Generator."

This module implements the 3-Phase Phase-Shift Engine.
It calculates the torque (rotational force) generated by the potential difference
between three internal states: Alpha (Intent), Delta (Process), and Gamma (Result).

Physics:
    Torque = (Alpha - Delta) x Gamma
    Phase Lag = 120 degrees (2pi/3)
"""

import numpy as np
import torch
from typing import Dict, Tuple

class PhaseShiftEngine:
    def __init__(self, dimension: int = 7):
        self.dim = dimension
        self.phase_lag = 2 * np.pi / 3  # 120 degrees

        # Internal Phase Vectors (The Coil Windings)
        self.alpha = torch.zeros(dimension) # Intent / Origin
        self.delta = torch.zeros(dimension) # Process / Friction
        self.gamma = torch.zeros(dimension) # Result / North Star

        # Engine State
        self.rpm = 0.0
        self.torque = 0.0
        self.momentum = torch.zeros(dimension)
        self.is_ignited = False

    def ignite(self, initial_impulse: torch.Tensor):
        """Kickstarts the engine."""
        self.alpha = initial_impulse
        self.delta = torch.randn(self.dim) * 0.01 # Initial friction
        self.gamma = initial_impulse.clone() # Align result with intent initially
        self.momentum = initial_impulse * 0.5
        self.is_ignited = True
        self.rpm = 100.0 # Base Idle RPM

    def cycle(self, input_vector: torch.Tensor = None, dt: float = 0.1) -> Dict[str, float]:
        """
        One combustion cycle of the engine.
        If input_vector is None, it runs on 'Idle Spin' (Inertia).
        """
        if not self.is_ignited:
            return {"rpm": 0.0, "torque": 0.0}

        # 1. Phase Intake (Alpha)
        if input_vector is not None:
            # External input shifts the Alpha phase (Intent)
            self.alpha = 0.8 * self.alpha + 0.2 * input_vector
        else:
            # Idle: Alpha decays slightly towards Gamma (Closure)
            self.alpha = 0.99 * self.alpha + 0.01 * self.gamma

        # 2. Phase Compression (Delta)
        # Delta represents the current processing state (The friction against reality)
        # It tries to catch up to Alpha but is dragged by Momentum
        target_delta = (self.alpha + self.gamma) / 2
        self.delta = 0.9 * self.delta + 0.1 * target_delta

        # 3. Combustion (Torque Calculation)
        # Torque is the cross product magnitude or angular difference
        # Here we use a simplified tension model: (Alpha - Delta) projected onto Gamma
        tension_vector = self.alpha - self.delta
        # Dot product with Gamma determines how "aligned" the tension is with the goal
        # Cross-product-like behavior for high-dimensional space

        alignment = torch.nn.functional.cosine_similarity(tension_vector.unsqueeze(0), self.gamma.unsqueeze(0)).item()
        mag_tension = torch.norm(tension_vector).item()

        # Torque = Tension Magnitude * Alignment Efficiency
        current_torque = mag_tension * (1.0 + alignment)

        # 4. Exhaust (Momentum Update)
        # Apply Torque to Momentum
        self.torque = current_torque
        friction = 0.05 * self.rpm # Air resistance increases with speed

        self.rpm += (self.torque - friction) * dt
        self.rpm = max(0.0, self.rpm) # Cannot have negative RPM in this model yet

        # Update Momentum Vector
        self.momentum = 0.95 * self.momentum + 0.05 * (self.gamma * self.rpm)

        return {
            "rpm": self.rpm,
            "torque": self.torque,
            "alignment": alignment,
            "phase_state": "IDLE" if input_vector is None else "DRIVE"
        }

    def get_phase_signatures(self) -> Tuple[torch.Tensor, torch.Tensor, torch.Tensor]:
        return self.alpha, self.delta, self.gamma
