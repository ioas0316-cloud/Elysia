"""
Hangul Physics Module
=====================
This module defines the physical properties of Hangul characters (Jamo) and the
mechanism to translate internal physics (Tensor3D, FrequencyWave) into sound.

It grounds language in the agent's simulated physical reality.
"""

from dataclasses import dataclass, field
from typing import Dict, List, Optional, Tuple
import math
import random

# Reuse existing physics structures if available, or define minimal versions here
# to avoid circular imports during this prototype phase.
@dataclass
class Tensor3D:
    x: float
    y: float
    z: float

    def magnitude(self) -> float:
        return math.sqrt(self.x**2 + self.y**2 + self.z**2)

    def roughness(self) -> float:
        """
        Estimate 'roughness' based on high-frequency variance or sharp transitions.
        For this prototype, we use the ratio of max component to magnitude.
        """
        mag = self.magnitude()
        if mag == 0: return 0.0
        return max(abs(self.x), abs(self.y), abs(self.z)) / mag

@dataclass
class SoundWave:
    """
    Represents a sound wave generated by the agent.
    """
    frequency: float  # Pitch
    amplitude: float  # Volume
    timbre: float     # Roughness/Texture (0.0=Sine, 1.0=Noise)
    duration: float   # Seconds

@dataclass
class JamoPhysics:
    """
    Physical properties of a single Hangul Jamo.
    """
    char: str
    type: str  # 'consonant' or 'vowel'
    roughness: float  # 0.0 (Smooth) to 1.0 (Rough)
    openness: float   # 0.0 (Closed) to 1.0 (Open)
    tension: float    # 0.0 (Lax) to 1.0 (Tense)

class HangulPhysicsEngine:
    # Standard Unicode Jamo lists
    CHOSEONG = [' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',
                ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ']

    JUNGSEONG = [' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',
                 ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ']

    JONGSEONG = ['', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',
                 ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',
                 ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ']

    def __init__(self):
        self.jamo_map = self._initialize_jamo_physics()

    def _initialize_jamo_physics(self) -> Dict[str, JamoPhysics]:
        """
        Maps Hangul Jamo to physical properties.
        """
        mapping = {}
        
        # --- Consonants (Roughness & Tension) ---
        # Velars ( ,  ,  ) - Rough, explosive
        mapping[' '] = JamoPhysics(' ', 'consonant', roughness=0.7, openness=0.2, tension=0.4)
        mapping[' '] = JamoPhysics(' ', 'consonant', roughness=0.9, openness=0.3, tension=0.8)
        mapping[' '] = JamoPhysics(' ', 'consonant', roughness=1.0, openness=0.1, tension=1.0)
        
        # Alveolars ( ,  ,  ,  ,  ) - Smooth to hard
        mapping[' '] = JamoPhysics(' ', 'consonant', roughness=0.1, openness=0.4, tension=0.1)
        mapping[' '] = JamoPhysics(' ', 'consonant', roughness=0.5, openness=0.2, tension=0.5)
        mapping[' '] = JamoPhysics(' ', 'consonant', roughness=0.8, openness=0.3, tension=0.8)
        mapping[' '] = JamoPhysics(' ', 'consonant', roughness=0.9, openness=0.1, tension=1.0)
        mapping[' '] = JamoPhysics(' ', 'consonant', roughness=0.2, openness=0.6, tension=0.2) # Flowing
        
        # Bilabials ( ,  ,  ,  ) - Soft to popping
        mapping[' '] = JamoPhysics(' ', 'consonant', roughness=0.1, openness=0.3, tension=0.1)
        mapping[' '] = JamoPhysics(' ', 'consonant', roughness=0.4, openness=0.2, tension=0.3)
        mapping[' '] = JamoPhysics(' ', 'consonant', roughness=0.7, openness=0.3, tension=0.7)
        mapping[' '] = JamoPhysics(' ', 'consonant', roughness=0.8, openness=0.1, tension=0.9)
        
        # Sibilants ( ,  ,  ,  ,  ) - Sharp
        mapping[' '] = JamoPhysics(' ', 'consonant', roughness=0.6, openness=0.4, tension=0.4)
        mapping[' '] = JamoPhysics(' ', 'consonant', roughness=0.9, openness=0.3, tension=0.9)
        mapping[' '] = JamoPhysics(' ', 'consonant', roughness=0.5, openness=0.3, tension=0.5)
        mapping[' '] = JamoPhysics(' ', 'consonant', roughness=0.8, openness=0.4, tension=0.8)
        mapping[' '] = JamoPhysics(' ', 'consonant', roughness=0.9, openness=0.2, tension=1.0)
        
        # Glottal ( ,  ) - Airy
        mapping[' '] = JamoPhysics(' ', 'consonant', roughness=0.0, openness=0.8, tension=0.0) # Null sound / Nasal
        mapping[' '] = JamoPhysics(' ', 'consonant', roughness=0.3, openness=0.9, tension=0.2)

        # --- Vowels (Openness & Direction) ---
        # Bright ( ,  ,  ,  ) - Outward, Open
        mapping[' '] = JamoPhysics(' ', 'vowel', roughness=0.1, openness=1.0, tension=0.5)
        mapping[' '] = JamoPhysics(' ', 'vowel', roughness=0.1, openness=0.8, tension=0.6)
        mapping[' '] = JamoPhysics(' ', 'vowel', roughness=0.2, openness=1.0, tension=0.7)
        
        # Dark ( ,  ,  ,  ) - Inward, Closed
        mapping[' '] = JamoPhysics(' ', 'vowel', roughness=0.2, openness=0.6, tension=0.4)
        mapping[' '] = JamoPhysics(' ', 'vowel', roughness=0.2, openness=0.4, tension=0.5)
        mapping[' '] = JamoPhysics(' ', 'vowel', roughness=0.3, openness=0.6, tension=0.6)
        
        # Neutral ( ,  )
        mapping[' '] = JamoPhysics(' ', 'vowel', roughness=0.1, openness=0.5, tension=0.3)
        mapping[' '] = JamoPhysics(' ', 'vowel', roughness=0.1, openness=0.7, tension=0.8) # Tense

        return mapping

    def tensor_to_sound(self, tensor: Tensor3D) -> SoundWave:
        """
        Converts a physical tensor into a raw sound wave.
        """
        mag = tensor.magnitude()
        roughness = tensor.roughness()
        
        # Mapping rules:
        # Magnitude -> Amplitude (Volume)
        # Roughness -> Timbre (Texture)
        # X/Y/Z balance -> Frequency (Pitch) - simplified
        
        amplitude = min(1.0, mag / 10.0) # Normalize
        frequency = 200.0 + (abs(tensor.z) * 100.0) # Z-axis affects pitch
        
        return SoundWave(
            frequency=frequency,
            amplitude=amplitude,
            timbre=roughness,
            duration=0.5
        )

    def find_closest_jamo(self, target_roughness: float, target_tension: float, type_filter: str = None) -> str:
        """
        Finds the Jamo that best matches the target physical properties.
        """
        best_jamo = None
        min_dist = float('inf')
        
        candidates = self.jamo_map.values()
        if type_filter:
            candidates = [j for j in candidates if j.type == type_filter]
            
        for jamo in candidates:
            # Euclidean distance in (roughness, tension) space
            dist = math.sqrt(
                (jamo.roughness - target_roughness)**2 + 
                (jamo.tension - target_tension)**2
            )
            
            # Add some noise for "babbling" variability
            dist += random.uniform(-0.05, 0.05)
            
            if dist < min_dist:
                min_dist = dist
                best_jamo = jamo.char
                
        return best_jamo or ' '

    def synthesize_syllable(self, onset: str, nucleus: str, coda: str = '') -> str:
        """
        Combines Jamo into a Hangul syllable using proper Unicode composition logic.
        Formula: 0xAC00 + (Choseong_Index * 588) + (Jungseong_Index * 28) + Jongseong_Index
        """
        try:
            # Find indices in the standard lists
            onset_idx = self.CHOSEONG.index(onset)
            nucleus_idx = self.JUNGSEONG.index(nucleus)
            coda_idx = self.JONGSEONG.index(coda) if coda else 0

            # Calculate Unicode code point
            # 588 = 21 * 28
            code = 0xAC00 + (onset_idx * 588) + (nucleus_idx * 28) + coda_idx
            return chr(code)

        except ValueError:
            # Fallback if provided Jamo are not standard or not found
            # This handles cases where partial or invalid Jamo might be passed
            if coda:
                return f"{onset}{nucleus}{coda}"
            return f"{onset}{nucleus}"

@dataclass
class GrammarParticle:
    """
    Represents a grammatical particle as a physical operator.
    """
    surface_form: str  # e.g., " ", " "
    role: str          # "subject_marker", "object_marker"
    energy_type: str   # "spark", "field", "ground"
    
    def apply(self, tensor: Tensor3D) -> Tensor3D:
        """
        Modifies the tensor of the preceding word based on the particle's physics.
        """
        if self.energy_type == "spark":
            # Subject marker: Ignites flow, adds high frequency jitter
            return Tensor3D(tensor.x * 1.2, tensor.y * 1.2, tensor.z + 5.0)
        elif self.energy_type == "field":
            # Object marker: Creates a gravity well, dampens magnitude but increases density
            return Tensor3D(tensor.x * 0.8, tensor.y * 0.8, tensor.z * 0.5)
        elif self.energy_type == "ground":
            # Sentence end: Stabilizes everything to rest
            return Tensor3D(0.0, 0.0, 0.0)
        return tensor

class GrammarPhysics:
    def __init__(self):
        self.particles = self._initialize_particles()
        
    def _initialize_particles(self) -> Dict[str, GrammarParticle]:
        return {
            "subject": GrammarParticle(" ", "subject_marker", "spark"), # Simplified: always 'ga'
            "object": GrammarParticle(" ", "object_marker", "field"),   # Simplified: always 'reul'
            "end": GrammarParticle(" ", "sentence_end", "ground")
        }
    
    def get_particle(self, role: str) -> GrammarParticle:
        return self.particles.get(role)
