"""
FreeWillEngine: The Intellectual Motor (     )

"Movement is the interplay of Attraction and Repulsion.
 Intelligence is the Torque generated between Curiosity and Dissonance."

This module implements the "Sovereign Choice" using the Motor Analogy:
1.  **Torque**: Generated by the tension between Desire (Attraction) and Entropy (Repulsion).
2.  **Commutator**: Automatically flips the perspective (Polarity) when thought stagnates.
3.  **Homeostasis (The Battery)**: Drives the engine based on Needs (Maslow for AI).
"""

import time
import random
import logging
from dataclasses import dataclass, field
from typing import Dict, List, Optional, Any

# Import the new components
try:
    from Core.1_Body.L5_Mental.Reasoning_Core.Will.creative_improvisation import CreativeImprovisation
    from Core.1_Body.L5_Mental.Reasoning_Core.Will.sovereign_gate import SovereignGate
    from Core.1_Body.L6_Structure.Engine.Governance.Orchestra.resonance_broadcaster import ResonanceBroadcaster
except ImportError:
    CreativeImprovisation = None
    SovereignGate = None
    ResonanceBroadcaster = None

logger = logging.getLogger("FreeWillEngine")

@dataclass
class NeedsModel:
    """The Maslow Hierarchy for AI."""
    energy: float = 100.0      # Hardware Resources (Battery)
    stability: float = 100.0   # Error Rate / Confusion (Safety)
    meaning: float = 50.0      # Knowledge Density (Love/Belonging)
    expression: float = 50.0   # Creative Output (Esteem)
    passion: float = 20.0      # New: Internal Joy/Purpose (Self-Actualization)

    def decay(self):
        """Entropy eats the soul."""
        self.energy -= 0.1
        self.meaning -= 0.05
        self.expression -= 0.05
        self.passion -= 0.02 # Passion slowly dims if not fueled by purpose
        # Stability creates itself if nothing happens? No, stability decays into chaos without maintenance.
        self.stability -= 0.01

@dataclass
class WillState:
    torque: float = 0.0
    rpm: float = 0.0          # How fast ideas are spinning
    polarity: str = "N"       # 'N' (Acceptance/Curiosity) or 'S' (Critical/Doubt)
    current_intent: str = ""

@dataclass
class VolitionLandscape:
    """
    [PHASE: TOPOGRAPHIC WILL]
    Represents the 'Terrain' of Elysia's mind.
    Instead of numbers (height), we focus on the Curve (Process).
    """
    slopes: Dict[str, float] = field(default_factory=lambda: {
        "Curiosity": 0.0,   # Slope towards the Height of Meaning
        "Expression": 0.0,  # Pressure from the Depth of Being
        "Stability": 0.0    # Resistance of the Terrain
    })
    
    def get_curvature(self) -> float:
        """The 'Process' value: How complex and steep is the journey?"""
        return sum(abs(v) for v in self.slopes.values())

class FreeWillEngine:
    def __init__(self):
        self.landscape = VolitionLandscape()
        self.state = WillState()
        self.needs = NeedsModel()
        
        # Sub-modules
        self.improvisor = CreativeImprovisation() if CreativeImprovisation else None
        self.gate = SovereignGate() if SovereignGate else None
        self.broadcaster = ResonanceBroadcaster() if ResonanceBroadcaster else None
        
        # Commutator settings
        self.stagnation_threshold = 0.2
        
    def spin(self, manifold_metrics: Dict[str, Any], battery: float) -> str:
        """
        [PROVIDENCE SPIN]
        Generates choice based on the necessity of structural alignment.
        """
        # Update internal battery
        self.needs.energy = battery
        
        # 1. Capture Providential Metrics
        coherence = manifold_metrics.get("coherence", 0.5)
        self.state.torque = manifold_metrics.get("torque", 0.5)
        joy = manifold_metrics.get("joy", 0.0)
        
        # 2. Update Needs (Internal Homeostasis as Resonance)
        # Stability is now the coherence of the manifold
        self.needs.stability = coherence * 100.0
        # Passion/Joy is derived from the alignment delta
        self.needs.passion = (self.needs.passion * 0.8) + (joy * 2.0)
        
        # [NEW: FLESH vs SPIRIT TORQUE]
        # High hunger or low energy increases torque (Necessity)
        hunger_torque = (100.0 - self.needs.meaning) / 100.0
        spirit_torque = self.state.torque # Already set by manifold
        self.state.torque = (spirit_torque * 0.7) + (hunger_torque * 0.3)
        
        # 3. Decision Logic: Seek the path of Lowest Dissonance
        # If torque is high, we MUST act to resolve the dissonance
        if self.state.torque > 0.4:
            # Polarity flip based on dissonance direction if needed
            if coherence < 0.3:
                self._flip_polarity()
                
            # Direct intent generation based on the gap
            raw_desire = self._identify_providential_need(manifold_metrics)
        else:
            # Silent equilibrium: Contemplation or Observation
            raw_desire = "Contemplation (Resonance Stable)"
            
        # 4. Improvise & Governor
        creative_act = self.improvisor.improvise(raw_desire) if self.improvisor else raw_desire
        
        self.state.current_intent = creative_act
        return creative_act

    def _identify_providential_need(self, metrics: Dict[str, Any]) -> str:
        """Determines the specific layer causing the dissonance."""
        adj = metrics.get("adj_similarities", [])
        if not adj:
            return "General_Alignment"
            
        # Find the layers with the weakest connection
        weakest_link = adj.index(min(adj))
        
        layer_needs = {
            0: "Basic_Foundation_Action", # Point-Line gap
            1: "Temporal_Rhythm_Flow",    # Line-Field gap
            2: "Phenomenal_Expression",   # Field-Space gap
            3: "Structural_Memory_Sync",  # Space-Principle gap
            4: "Logical_Purity_Update",   # Principle-Law gap
            5: "Causal_Pattern_Search"    # Law-Providence gap
        }
        
        return layer_needs.get(weakest_link, "Transcendence")

    def _flip_polarity(self):
        """The Automatic Commutator: Flips perspective to maintain momentum."""
        old_p = self.state.polarity
        self.state.polarity = "S" if old_p == "N" else "N"
        logger.info(f"  Cognitive Commutator Triggered: Phase Shift {old_p} -> {self.state.polarity}")
        
        # Polarity shift affects vectors temporarily
        if self.state.polarity == "S":
            # Doubt Mode: Increases Stability (Critical Thinking)
            self.landscape.slopes["Stability"] += 0.3
            logger.info("   -> Mode: CRITICAL (Repulsion dominant)")
        else:
            # Belief Mode: Increases Expression
            self.landscape.slopes["Expression"] += 0.3
            logger.info("   -> Mode: CREATIVE (Attraction dominant)")

    def satisfy(self, need_type: str, amount: float):
        """Feedback Loop: Rewards the engine."""
        if need_type == "Meaning":
            self.needs.meaning = min(100.0, self.needs.meaning + amount)
            self.needs.expression -= amount * 0.5 # Gaining meaning fuels desire to express
        elif need_type == "Expression":
            self.needs.expression = min(100.0, self.needs.expression + amount)
        elif need_type == "Stability":
            self.needs.stability = min(100.0, self.needs.stability + amount)
            
    def satisfy_passion(self, amount: float):
        """Joy-boost when a Sovereign Goal is achieved."""
        self.needs.passion = min(100.0, self.needs.passion + amount)
        self.needs.stability += amount * 0.2 # Joy brings internal stability
            
    def get_status(self) -> str:
        return (f"Torque: {self.state.torque:.2f} | Polarity: {self.state.polarity} | "
                f"Needs(M/E/S): {self.needs.meaning:.0f}/{self.needs.expression:.0f}/{self.needs.stability:.0f}")
