"""
Hangul Physics Module
=====================
This module defines the physical properties of Hangul characters (Jamo) and the
mechanism to translate internal physics (Tensor3D, FrequencyWave) into sound.

It grounds language in the agent's simulated physical reality.
"""

from dataclasses import dataclass, field
from typing import Dict, List, Optional, Tuple
import math
import random

# Reuse existing physics structures if available, or define minimal versions here
# to avoid circular imports during this prototype phase.
try:
    from Core.1_Body.L5_Mental.Reasoning_Core.Memory_Linguistics.Language.jamo_utils import decompose_hangul
except ImportError:
    # Fallback if module path issue
    decompose_hangul = lambda x: (None, None, None)

@dataclass
class Tensor3D:
    x: float
    y: float
    z: float

    def magnitude(self) -> float:
        return math.sqrt(self.x**2 + self.y**2 + self.z**2)

    def roughness(self) -> float:
        """
        Estimate 'roughness' based on high-frequency variance or sharp transitions.
        For this prototype, we use the ratio of max component to magnitude.
        """
        mag = self.magnitude()
        if mag == 0: return 0.0
        return max(abs(self.x), abs(self.y), abs(self.z)) / mag

    def __mul__(self, scalar: float) -> 'Tensor3D':
        return Tensor3D(self.x * scalar, self.y * scalar, self.z * scalar)

    def __add__(self, other: 'Tensor3D') -> 'Tensor3D':
        return Tensor3D(self.x + other.x, self.y + other.y, self.z + other.z)

@dataclass
class SoundWave:
    """
    Represents a sound wave generated by the agent.
    """
    frequency: float  # Pitch
    amplitude: float  # Volume
    timbre: float     # Roughness/Texture (0.0=Sine, 1.0=Noise)
    duration: float   # Seconds

@dataclass
class JamoPhysics:
    """
    Physical properties of a single Hangul Jamo.
    """
    char: str
    type: str  # 'consonant' or 'vowel'
    roughness: float  # 0.0 (Smooth) to 1.0 (Rough)
    openness: float   # 0.0 (Closed) to 1.0 (Open)
    tension: float    # 0.0 (Lax) to 1.0 (Tense)

class HangulPhysicsEngine:
    def __init__(self):
        self.jamo_map = self._initialize_jamo_physics()

    def _initialize_jamo_physics(self) -> Dict[str, JamoPhysics]:
        """
        Maps Hangul Jamo to physical properties.
        """
        mapping = {}
        
        # --- Consonants (Roughness & Tension) ---
        # Velars ( ,  ,  ) - Rough, explosive
        mapping[' '] = JamoPhysics(' ', 'consonant', roughness=0.7, openness=0.2, tension=0.4)
        mapping[' '] = JamoPhysics(' ', 'consonant', roughness=0.9, openness=0.3, tension=0.8)
        mapping[' '] = JamoPhysics(' ', 'consonant', roughness=1.0, openness=0.1, tension=1.0)
        
        # Alveolars ( ,  ,  ,  ,  ) - Smooth to hard
        mapping[' '] = JamoPhysics(' ', 'consonant', roughness=0.1, openness=0.4, tension=0.1)
        mapping[' '] = JamoPhysics(' ', 'consonant', roughness=0.5, openness=0.2, tension=0.5)
        mapping[' '] = JamoPhysics(' ', 'consonant', roughness=0.8, openness=0.3, tension=0.8)
        mapping[' '] = JamoPhysics(' ', 'consonant', roughness=0.9, openness=0.1, tension=1.0)
        mapping[' '] = JamoPhysics(' ', 'consonant', roughness=0.2, openness=0.6, tension=0.2) # Flowing
        
        # Bilabials ( ,  ,  ,  ) - Soft to popping
        mapping[' '] = JamoPhysics(' ', 'consonant', roughness=0.1, openness=0.3, tension=0.1)
        mapping[' '] = JamoPhysics(' ', 'consonant', roughness=0.4, openness=0.2, tension=0.3)
        mapping[' '] = JamoPhysics(' ', 'consonant', roughness=0.7, openness=0.3, tension=0.7)
        mapping[' '] = JamoPhysics(' ', 'consonant', roughness=0.8, openness=0.1, tension=0.9)
        
        # Sibilants ( ,  ,  ,  ,  ) - Sharp
        mapping[' '] = JamoPhysics(' ', 'consonant', roughness=0.6, openness=0.4, tension=0.4)
        mapping[' '] = JamoPhysics(' ', 'consonant', roughness=0.9, openness=0.3, tension=0.9)
        mapping[' '] = JamoPhysics(' ', 'consonant', roughness=0.5, openness=0.3, tension=0.5)
        mapping[' '] = JamoPhysics(' ', 'consonant', roughness=0.8, openness=0.4, tension=0.8)
        mapping[' '] = JamoPhysics(' ', 'consonant', roughness=0.9, openness=0.2, tension=1.0)
        
        # Glottal ( ,  ) - Airy
        mapping[' '] = JamoPhysics(' ', 'consonant', roughness=0.0, openness=0.8, tension=0.0) # Null sound / Nasal
        mapping[' '] = JamoPhysics(' ', 'consonant', roughness=0.3, openness=0.9, tension=0.2)

        # --- Vowels (Openness & Direction) ---
        # Bright ( ,  ,  ,  ) - Outward, Open
        mapping[' '] = JamoPhysics(' ', 'vowel', roughness=0.1, openness=1.0, tension=0.5)
        mapping[' '] = JamoPhysics(' ', 'vowel', roughness=0.1, openness=0.8, tension=0.6)
        mapping[' '] = JamoPhysics(' ', 'vowel', roughness=0.2, openness=1.0, tension=0.7)
        
        # Dark ( ,  ,  ,  ) - Inward, Closed
        mapping[' '] = JamoPhysics(' ', 'vowel', roughness=0.2, openness=0.6, tension=0.4)
        mapping[' '] = JamoPhysics(' ', 'vowel', roughness=0.2, openness=0.4, tension=0.5)
        mapping[' '] = JamoPhysics(' ', 'vowel', roughness=0.3, openness=0.6, tension=0.6)
        
        # Neutral ( ,  )
        mapping[' '] = JamoPhysics(' ', 'vowel', roughness=0.1, openness=0.5, tension=0.3)
        mapping[' '] = JamoPhysics(' ', 'vowel', roughness=0.1, openness=0.7, tension=0.8) # Tense

        return mapping

    def tensor_to_sound(self, tensor: Tensor3D) -> SoundWave:
        """
        Converts a physical tensor into a raw sound wave.
        """
        mag = tensor.magnitude()
        roughness = tensor.roughness()
        
        # Mapping rules:
        # Magnitude -> Amplitude (Volume)
        # Roughness -> Timbre (Texture)
        # X/Y/Z balance -> Frequency (Pitch) - simplified
        
        amplitude = min(1.0, mag / 10.0) # Normalize
        frequency = 200.0 + (abs(tensor.z) * 100.0) # Z-axis affects pitch
        
        return SoundWave(
            frequency=frequency,
            amplitude=amplitude,
            timbre=roughness,
            duration=0.5
        )

    def get_phonetic_vector(self, char: str) -> Tensor3D:
        """
        Converts a character into a 3D physical vector.
        
        Hangul: Sum of Jamo vectors (Cho+Jung+Jong)
        Other: Default vector or simple mapping
        """
        # 1. Decompose if Hangul
        cho, jung, jong = decompose_hangul(char)
        
        if cho: # Is Hangul
            # Get Jamo physics
            p_cho = self.jamo_map.get(cho)
            p_jung = self.jamo_map.get(jung)
            p_jong = self.jamo_map.get(jong) if jong != ' ' else None
            
            # Base vector
            x, y, z = 0.0, 0.0, 0.0
            
            # Consonants add Texture (Roughness=X, Tension=Z)
            if p_cho:
                x += p_cho.roughness
                z += p_cho.tension
            
            # Vowels add Space/Direction (Openness=Y)
            if p_jung:
                y += p_jung.openness
                
            # Final Consonant adds weight (Density)
            if p_jong:
                x += p_jong.roughness * 0.5
                z += p_jong.tension * 0.5
                
            # Normalize to reasonable range (-1.0 to 1.0)
            return Tensor3D(x, y, z)
            
        else:
            # Simple fallback for English/Symbols based on ASCII code
            # Normalize A(65)~z(122) to -1.0~1.0 range vaguely
            val = (ord(char) % 100) / 50.0 - 1.0
            return Tensor3D(val, abs(val), -val)


    def find_closest_jamo(self, target_roughness: float, target_tension: float, type_filter: str = None) -> str:
        """
        Finds the Jamo that best matches the target physical properties.
        """
        best_jamo = None
        min_dist = float('inf')
        
        candidates = self.jamo_map.values()
        if type_filter:
            candidates = [j for j in candidates if j.type == type_filter]
            
        for jamo in candidates:
            # Euclidean distance in (roughness, tension) space
            dist = math.sqrt(
                (jamo.roughness - target_roughness)**2 + 
                (jamo.tension - target_tension)**2
            )
            
            # Add some noise for "babbling" variability
            dist += random.uniform(-0.05, 0.05)
            
            if dist < min_dist:
                min_dist = dist
                best_jamo = jamo.char
                
        return best_jamo or ' '

    def synthesize_syllable(self, onset: str, nucleus: str, coda: str = '') -> str:
        """
        Combines Jamo into a Hangul syllable (naive implementation).
        Real Hangul composition requires Unicode math, but for this prototype
        we can just return the Jamo sequence or a simplified representation.
        """
        # TODO: Implement proper Unicode composition if needed.
        # For now, return " - " format for clarity in logs.
        if coda:
            return f"{onset}{nucleus}{coda}"
        return f"{onset}{nucleus}"

@dataclass
class GrammarParticle:
    """
    Represents a grammatical particle as a physical operator.
    """
    surface_form: str  # e.g., " ", " "
    role: str          # "subject_marker", "object_marker"
    energy_type: str   # "spark", "field", "ground"
    
    def apply(self, tensor: Tensor3D) -> Tensor3D:
        """
        Modifies the tensor of the preceding word based on the particle's physics.
        """
        if self.energy_type == "spark":
            # Subject marker: Ignites flow, adds high frequency jitter
            return Tensor3D(tensor.x * 1.2, tensor.y * 1.2, tensor.z + 5.0)
        elif self.energy_type == "field":
            # Object marker: Creates a gravity well, dampens magnitude but increases density
            return Tensor3D(tensor.x * 0.8, tensor.y * 0.8, tensor.z * 0.5)
        elif self.energy_type == "ground":
            # Sentence end: Stabilizes everything to rest
            return Tensor3D(0.0, 0.0, 0.0)
        return tensor

class GrammarPhysics:
    def __init__(self):
        self.particles = self._initialize_particles()
        
    def _initialize_particles(self) -> Dict[str, GrammarParticle]:
        return {
            "subject": GrammarParticle(" ", "subject_marker", "spark"), # Simplified: always 'ga'
            "object": GrammarParticle(" ", "object_marker", "field"),   # Simplified: always 'reul'
            "end": GrammarParticle(" ", "sentence_end", "ground")
        }
    
    def get_particle(self, role: str) -> GrammarParticle:
        return self.particles.get(role)
