"""
Elysia Field - ì—˜ë¦¬ì‹œì•„ í•„ë“œ (ì–‘ì/ê´‘ì ê¸°ë°˜ ìˆ˜ë™ì  ì¸ì§€ ì‹œìŠ¤í…œ)
================================================================

ì•„ë²„ì§€ì˜ í†µì°°:
"ì–‘ìì‹œìŠ¤í…œì´ë‚˜ ê´‘ìì‹œìŠ¤í…œì„ ì´ë¤„ì„œ í˜„ì‹¤ì— ì—˜ë¦¬ì‹œì•„í•„ë“œë¥¼ ê¹”ê²Œë¼ì„œ 
 ì‹ í˜¸ë“±ì´ë‚˜ CCTVì— ì¡°ì‘ê¶Œí•œì´ ì—†ì–´ë„ ê·¸ ì‹ í˜¸ì²´ê³„ë¥¼ ëª¨ë‘ í†µì°°í• ìˆ˜ ìˆê³  
 íˆ¬ê³¼í•´ì„œ íŒŒì•…í• ìˆ˜ ìˆë‹¤ë©´ ì´ê±´ í•´í‚¹ì¸ê°€ í•´í‚¹ì´ ì•„ë‹Œê°€..? 
 ë§Œì¼ ê°€ëŠ¥í•˜ë‹¤ë©´ ê·¸ëƒ¥ ëˆˆë§Œ ë–´ëŠ”ë° ëª¨ë“ ê²Œ ë³´ì´ëŠ”ê±°ì–ì•„."

í•µì‹¬ ê°œë…:
- ì´ê²ƒì€ "í•´í‚¹"ì´ ì•„ë‹™ë‹ˆë‹¤
- ì´ê²ƒì€ "ëˆˆì„ ëœ¨ëŠ” ê²ƒ"ì…ë‹ˆë‹¤
- ì¡°ì‘(Manipulation) â‰  ê´€ì°°(Observation)
- ëª¨ë“  ì‹œìŠ¤í…œì€ ì „ìê¸° ì‹ í˜¸ë¥¼ ë°©ì¶œí•©ë‹ˆë‹¤ - ê·¸ê²ƒì„ "ëŠë¼ëŠ” ê²ƒ"

ì² í•™ì  êµ¬ë¶„:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  í•´í‚¹ (Hacking)           vs    ì—˜ë¦¬ì‹œì•„ í•„ë“œ (Elysia Field) â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  - ì‹œìŠ¤í…œì— ì¹¨ì…           â”‚    - ì‹œìŠ¤í…œ ë°–ì—ì„œ ê´€ì°°        â”‚
â”‚  - ê¶Œí•œ íƒˆì·¨               â”‚    - ê¶Œí•œ ë¶ˆí•„ìš”               â”‚
â”‚  - ë°ì´í„° ì¡°ì‘             â”‚    - ì‹ í˜¸ íŒ¨í„´ ì¸ì‹            â”‚
â”‚  - ëŠ¥ë™ì  ê³µê²©             â”‚    - ìˆ˜ë™ì  ìˆ˜ì‹                â”‚
â”‚  - ì‹œìŠ¤í…œ ë³€ê²½             â”‚    - ì‹œìŠ¤í…œ ë¬´ì˜í–¥             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  ë¹„ìœ : ì§‘ì— ì¹¨ì…           â”‚    ë¹„ìœ : ì§‘ì—ì„œ ë‚˜ì˜¤ëŠ” ë¹›ì„ ë´„ â”‚
â”‚        ê¸ˆê³  ì—´ê¸°           â”‚          ì°½ë¬¸ ë„ˆë¨¸ ë³´ê¸°        â”‚
â”‚        ìë¬¼ì‡  ë”°ê¸°         â”‚          ê³µê¸° ëƒ„ìƒˆ ë§¡ê¸°        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

ë¬¼ë¦¬ì  ì›ë¦¬:
1. ì „ìê¸°íŒŒ ìˆ˜ì‹ : ëª¨ë“  ì „ì ì¥ì¹˜ëŠ” ì „ìê¸°íŒŒë¥¼ ë°©ì¶œ (ë¼ë””ì˜¤ì²˜ëŸ¼)
2. ì–‘ì ì–½í˜: ê´‘ì ìƒíƒœë¥¼ í†µí•œ ì •ë³´ ìœ ì¶” (ì¸¡ì • ì•„ë‹Œ ìƒê´€ê´€ê³„)
3. ì—´ ë³µì‚¬: ëª¨ë“  ë¬¼ì²´ëŠ” ì—´ì„ ë°©ì¶œ (ì ì™¸ì„ ìœ¼ë¡œ "ë³´ì„")
4. ìŒíŒŒ/ì§„ë™: ëª¨ë“  ì¥ì¹˜ëŠ” ë¬¼ë¦¬ì  ì§„ë™ ìƒì„±

ë²•ì  ê´€ì :
- ê³µê°œëœ ì „ìê¸°íŒŒ ìˆ˜ì‹  = í•©ë²• (ë¼ë””ì˜¤ì™€ ë™ì¼)
- ì‹œìŠ¤í…œ ì¹¨íˆ¬ ì—†ìŒ = í•´í‚¹ ì•„ë‹˜
- ë°ì´í„° ë³€ì¡° ì—†ìŒ = íŒŒê´´ ì•„ë‹˜
- ìˆ˜ë™ì  ê´€ì°° = ê°ê° í™•ì¥

í˜„ì‹¤ ê¸°ìˆ  ì°¸ê³ :
- TEMPEST: ì „ìê¸° ë°©ì‚¬ë¥¼ í†µí•œ ì •ë³´ ìˆ˜ì§‘ (ì‹¤ì œ ì¡´ì¬)
- ì—´í™”ìƒ ì¹´ë©”ë¼: ì—´ ë°©ì‚¬ë¥¼ í†µí•œ "íˆ¬ì‹œ"
- ì „íŒŒ ë§ì›ê²½: ì „ìê¸°íŒŒ ìˆ˜ì‹ ìœ¼ë¡œ ìš°ì£¼ ê´€ì°°
- ì–‘ì ì„¼ì„œ: ê·¹ë¯¸ì•½ ìê¸°ì¥ ê°ì§€
"""

import hashlib
import json
import logging
import math
import time
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from pathlib import Path
from typing import Any, Callable, Dict, List, Optional, Tuple

logger = logging.getLogger("ElysiaField")

# ìƒìˆ˜ ì •ì˜ (ë¬¼ë¦¬ì  ëª¨ë¸ë§)
# í•„ë“œ ì—…ë°ì´íŠ¸ ê°„ê²©: 100ms (ì¸ê°„ ë°˜ì‘ ì‹œê°„ì˜ 1/3)
FIELD_UPDATE_INTERVAL = 0.1  # ì´ˆ

# ìµœëŒ€ ì¸ì§€ ë²”ìœ„: 1km (ê°œë…ì , ì‹¤ì œ ì–‘ì ì„¼ì„œëŠ” ì œí•œì )
MAX_PERCEPTION_RANGE = 1000.0  # ë¯¸í„°

# ì‹ í˜¸ ê°ì‡ ìœ¨: ì—­ì œê³± ë²•ì¹™ ê¸°ë°˜ (1/(1 + rate * distance))
# 0.1 = 10mì—ì„œ ì•½ 50% ê°ì‡ 
SIGNAL_DECAY_RATE = 0.1  # ë¯¸í„°ë‹¹ ê°ì‡  ê³„ìˆ˜

# ìµœì†Œ ì‹ í˜¸ ê°•ë„: ë…¸ì´ì¦ˆ í”Œë¡œì–´ (0.1% ë¯¸ë§Œì€ ë¬´ì‹œ)
MIN_SIGNAL_STRENGTH = 0.001  # 0.0~1.0 ë²”ìœ„ì—ì„œ


class PerceptionMode(Enum):
    """ì¸ì§€ ëª¨ë“œ"""
    ELECTROMAGNETIC = "electromagnetic"  # ì „ìê¸°íŒŒ ìˆ˜ì‹ 
    QUANTUM = "quantum"  # ì–‘ì ìƒê´€ê´€ê³„
    THERMAL = "thermal"  # ì—´ ë³µì‚¬
    ACOUSTIC = "acoustic"  # ìŒíŒŒ/ì§„ë™
    PHOTONIC = "photonic"  # ê´‘ì í•„ë“œ


class LegalStatus(Enum):
    """ë²•ì  ìƒíƒœ"""
    PASSIVE_OBSERVATION = "passive_observation"  # ìˆ˜ë™ì  ê´€ì°° (í•©ë²•)
    SIGNAL_RECEPTION = "signal_reception"  # ì‹ í˜¸ ìˆ˜ì‹  (ë¼ë””ì˜¤ì™€ ë™ì¼)
    PATTERN_RECOGNITION = "pattern_recognition"  # íŒ¨í„´ ì¸ì‹ (ë¶„ì„)


@dataclass
class SignalSource:
    """ì‹ í˜¸ ì¶œì²˜"""
    source_id: str
    source_type: str  # traffic_light, cctv, phone, computer, etc.
    location: Tuple[float, float, float]  # x, y, z ì¢Œí‘œ
    signal_type: PerceptionMode
    frequency: float  # Hz (ê°œë…ì )
    last_detected: float = field(default_factory=time.time)
    
    def distance_from(self, point: Tuple[float, float, float]) -> float:
        """íŠ¹ì • ì§€ì ìœ¼ë¡œë¶€í„°ì˜ ê±°ë¦¬"""
        return math.sqrt(
            (self.location[0] - point[0])**2 +
            (self.location[1] - point[1])**2 +
            (self.location[2] - point[2])**2
        )


@dataclass
class FieldPerception:
    """í•„ë“œ ì¸ì§€ ê²°ê³¼"""
    source: SignalSource
    signal_strength: float  # 0.0 ~ 1.0
    pattern: str  # ì¸ì‹ëœ íŒ¨í„´
    meaning: str  # ì¶”ë¡ ëœ ì˜ë¯¸
    confidence: float  # ì‹ ë¢°ë„
    timestamp: float = field(default_factory=time.time)
    legal_status: LegalStatus = LegalStatus.PASSIVE_OBSERVATION
    
    def to_dict(self) -> Dict[str, Any]:
        """ë”•ì…”ë„ˆë¦¬ë¡œ ë³€í™˜"""
        return {
            "source_id": self.source.source_id,
            "source_type": self.source.source_type,
            "signal_strength": self.signal_strength,
            "pattern": self.pattern,
            "meaning": self.meaning,
            "confidence": self.confidence,
            "legal_status": self.legal_status.value,
            "timestamp": self.timestamp
        }


class ElysiaField:
    """
    ì—˜ë¦¬ì‹œì•„ í•„ë“œ - ìˆ˜ë™ì  ì¸ì§€ ì‹œìŠ¤í…œ
    
    "ëˆˆë§Œ ë–´ëŠ”ë° ëª¨ë“  ê²Œ ë³´ì´ëŠ” ê²ƒ"
    
    í•µì‹¬ ì›ë¦¬:
    1. ì¹¨íˆ¬í•˜ì§€ ì•ŠìŒ (No Intrusion)
    2. ì¡°ì‘í•˜ì§€ ì•ŠìŒ (No Manipulation)
    3. ê·¸ì € ëŠë‚Œ (Just Sensing)
    4. íŒ¨í„´ ì¸ì‹ (Pattern Recognition)
    
    ë¹„ìœ :
    - ë°•ì¥ê°€ ì´ˆìŒíŒŒë¡œ "ë³´ëŠ”" ê²ƒì²˜ëŸ¼
    - ë±€ì´ ì—´ì„ "ëŠë¼ëŠ”" ê²ƒì²˜ëŸ¼
    - ìƒì–´ê°€ ì „ê¸°ì¥ì„ "ê°ì§€í•˜ëŠ”" ê²ƒì²˜ëŸ¼
    """
    
    def __init__(
        self,
        center_point: Tuple[float, float, float] = (0, 0, 0),
        perception_range: float = MAX_PERCEPTION_RANGE
    ):
        self.center_point = center_point
        self.perception_range = min(perception_range, MAX_PERCEPTION_RANGE)
        
        # ê°ì§€ëœ ì‹ í˜¸ì›ë“¤
        self.detected_sources: Dict[str, SignalSource] = {}
        
        # ì¸ì§€ ê²°ê³¼
        self.perceptions: List[FieldPerception] = []
        
        # íŒ¨í„´ í•´ì„ê¸°
        self.pattern_interpreters: Dict[str, Callable] = {}
        
        # ì¸ì§€ ëª¨ë“œë³„ ê°ë„
        self.mode_sensitivity: Dict[PerceptionMode, float] = {
            mode: 0.5 for mode in PerceptionMode
        }
        
        # í†µê³„
        self.stats = {
            "total_perceptions": 0,
            "by_mode": {mode.value: 0 for mode in PerceptionMode},
            "by_source_type": {}
        }
        
        self._register_default_interpreters()
        
        logger.info(
            f"ElysiaField initialized: center={center_point}, "
            f"range={perception_range}m"
        )
    
    def _register_default_interpreters(self):
        """ê¸°ë³¸ íŒ¨í„´ í•´ì„ê¸° ë“±ë¡"""
        
        # ì‹ í˜¸ë“± íŒ¨í„´ í•´ì„
        def traffic_light_interpreter(signal_data: Dict[str, Any]) -> Tuple[str, str, float]:
            """ì‹ í˜¸ë“± ì‹ í˜¸ íŒ¨í„´ í•´ì„"""
            # ì‹¤ì œë¡œëŠ” ì „ìê¸° ì‹ í˜¸ íŒ¨í„´ìœ¼ë¡œ ì¶”ë¡ 
            # ì—¬ê¸°ì„œëŠ” ì‹œë®¬ë ˆì´ì…˜
            pattern = signal_data.get("pattern", "unknown")
            
            patterns = {
                "high_freq_pulse": ("ë…¹ìƒ‰ ì‹ í˜¸", "í†µí–‰ ê°€ëŠ¥", 0.9),
                "low_freq_pulse": ("ì ìƒ‰ ì‹ í˜¸", "ì •ì§€ ìƒíƒœ", 0.9),
                "alternating": ("í™©ìƒ‰ ì‹ í˜¸", "ì£¼ì˜ í•„ìš”", 0.85),
                "off": ("ì‹ í˜¸ êº¼ì§", "ì‹œìŠ¤í…œ ëŒ€ê¸°", 0.8),
            }
            
            return patterns.get(pattern, ("ì•Œ ìˆ˜ ì—†ìŒ", "íŒ¨í„´ ë¯¸ì¸ì‹", 0.3))
        
        # CCTV íŒ¨í„´ í•´ì„
        def cctv_interpreter(signal_data: Dict[str, Any]) -> Tuple[str, str, float]:
            """CCTV ì‹ í˜¸ íŒ¨í„´ í•´ì„"""
            pattern = signal_data.get("pattern", "unknown")
            
            patterns = {
                "continuous_transmission": ("ë…¹í™” ì¤‘", "í™œì„± ìƒíƒœ", 0.85),
                "intermittent": ("ê°„í—ì  ì „ì†¡", "ì›€ì§ì„ ê°ì§€ ëª¨ë“œ", 0.8),
                "standby": ("ëŒ€ê¸° ëª¨ë“œ", "ì €ì „ë ¥ ìƒíƒœ", 0.75),
                "data_burst": ("ë°ì´í„° ì „ì†¡", "ì˜ìƒ ì—…ë¡œë“œ ì¤‘", 0.8),
            }
            
            return patterns.get(pattern, ("ì•Œ ìˆ˜ ì—†ìŒ", "íŒ¨í„´ ë¯¸ì¸ì‹", 0.3))
        
        # ìŠ¤ë§ˆíŠ¸í° íŒ¨í„´ í•´ì„
        def phone_interpreter(signal_data: Dict[str, Any]) -> Tuple[str, str, float]:
            """ìŠ¤ë§ˆíŠ¸í° ì‹ í˜¸ íŒ¨í„´ í•´ì„"""
            pattern = signal_data.get("pattern", "unknown")
            
            patterns = {
                "active_communication": ("í†µí™”/ë°ì´í„° ì¤‘", "í™œë°œí•œ ì‚¬ìš©", 0.8),
                "idle_ping": ("ëŒ€ê¸° í•‘", "ì£¼ë¨¸ë‹ˆ ì•ˆ", 0.75),
                "wifi_searching": ("WiFi íƒìƒ‰", "ì—°ê²° ì‹œë„ ì¤‘", 0.7),
                "bluetooth_active": ("ë¸”ë£¨íˆ¬ìŠ¤ í™œì„±", "ê¸°ê¸° ì—°ê²°ë¨", 0.7),
            }
            
            return patterns.get(pattern, ("ì•Œ ìˆ˜ ì—†ìŒ", "íŒ¨í„´ ë¯¸ì¸ì‹", 0.3))
        
        # ì»´í“¨í„° íŒ¨í„´ í•´ì„
        def computer_interpreter(signal_data: Dict[str, Any]) -> Tuple[str, str, float]:
            """ì»´í“¨í„° ì‹ í˜¸ íŒ¨í„´ í•´ì„"""
            pattern = signal_data.get("pattern", "unknown")
            
            patterns = {
                "high_load": ("ê³ ë¶€í•˜ ìƒíƒœ", "ì§‘ì¤‘ ì‘ì—… ì¤‘", 0.8),
                "idle": ("ìœ íœ´ ìƒíƒœ", "ëŒ€ê¸° ì¤‘", 0.85),
                "network_active": ("ë„¤íŠ¸ì›Œí¬ í™œì„±", "ë°ì´í„° ì†¡ìˆ˜ì‹ ", 0.75),
                "display_active": ("ë””ìŠ¤í”Œë ˆì´ í™œì„±", "ì‚¬ìš©ì ìˆìŒ", 0.8),
            }
            
            return patterns.get(pattern, ("ì•Œ ìˆ˜ ì—†ìŒ", "íŒ¨í„´ ë¯¸ì¸ì‹", 0.3))
        
        self.pattern_interpreters = {
            "traffic_light": traffic_light_interpreter,
            "cctv": cctv_interpreter,
            "phone": phone_interpreter,
            "computer": computer_interpreter,
        }
    
    def detect_signal(
        self,
        source_id: str,
        source_type: str,
        location: Tuple[float, float, float],
        signal_type: PerceptionMode,
        frequency: float,
        signal_data: Dict[str, Any]
    ) -> Optional[FieldPerception]:
        """
        ì‹ í˜¸ ê°ì§€ (ìˆ˜ë™ì  ìˆ˜ì‹ )
        
        ì´ê²ƒì€ "í•´í‚¹"ì´ ì•„ë‹™ë‹ˆë‹¤.
        ì´ê²ƒì€ "ëˆˆì„ ëœ¨ëŠ” ê²ƒ"ì…ë‹ˆë‹¤.
        
        Args:
            source_id: ì‹ í˜¸ì› ID
            source_type: ì‹ í˜¸ì› ìœ í˜•
            location: ìœ„ì¹˜
            signal_type: ì‹ í˜¸ ìœ í˜•
            frequency: ì£¼íŒŒìˆ˜
            signal_data: ì‹ í˜¸ ë°ì´í„° (ìˆ˜ì‹ ëœ íŒ¨í„´)
        
        Returns:
            ì¸ì§€ ê²°ê³¼ (ë²”ìœ„ ë°–ì´ë©´ None)
        """
        # ì‹ í˜¸ì› ìƒì„±
        source = SignalSource(
            source_id=source_id,
            source_type=source_type,
            location=location,
            signal_type=signal_type,
            frequency=frequency
        )
        
        # ê±°ë¦¬ ê³„ì‚°
        distance = source.distance_from(self.center_point)
        
        # ë²”ìœ„ ë°–ì´ë©´ ë¬´ì‹œ
        if distance > self.perception_range:
            logger.debug(f"Signal out of range: {source_id} at {distance}m")
            return None
        
        # ì‹ í˜¸ ê°•ë„ ê³„ì‚° (ì—­ì œê³± ë²•ì¹™ ê¸°ë°˜ ê°ì‡ )
        # ë¬¼ë¦¬ ëª¨ë¸: S = S0 / (1 + k*d) where k=ê°ì‡ ê³„ìˆ˜, d=ê±°ë¦¬
        # ì´ëŠ” ê·¼ê±°ë¦¬ì—ì„œ ì„ í˜•ì— ê°€ê¹ê³ , ì›ê±°ë¦¬ì—ì„œ ì—­ë¹„ë¡€ì— ê°€ê¹Œì›€
        signal_strength = 1.0 / (1.0 + SIGNAL_DECAY_RATE * distance)
        signal_strength *= self.mode_sensitivity.get(signal_type, 0.5)
        
        # ìµœì†Œ ê°•ë„ ë¯¸ë§Œì´ë©´ ë¬´ì‹œ
        if signal_strength < MIN_SIGNAL_STRENGTH:
            return None
        
        # íŒ¨í„´ í•´ì„
        interpreter = self.pattern_interpreters.get(source_type)
        if interpreter:
            pattern, meaning, confidence = interpreter(signal_data)
        else:
            pattern = str(signal_data.get("pattern", "raw_signal"))
            meaning = "íŒ¨í„´ í•´ì„ê¸° ì—†ìŒ"
            confidence = 0.5
        
        # ì‹ í˜¸ ê°•ë„ì— ë”°ë¼ ì‹ ë¢°ë„ ì¡°ì •
        confidence *= signal_strength
        
        # ì¸ì§€ ê²°ê³¼ ìƒì„±
        perception = FieldPerception(
            source=source,
            signal_strength=signal_strength,
            pattern=pattern,
            meaning=meaning,
            confidence=confidence,
            legal_status=LegalStatus.PASSIVE_OBSERVATION
        )
        
        # ì €ì¥
        self.detected_sources[source_id] = source
        self.perceptions.append(perception)
        
        # í†µê³„ ì—…ë°ì´íŠ¸
        self.stats["total_perceptions"] += 1
        self.stats["by_mode"][signal_type.value] = \
            self.stats["by_mode"].get(signal_type.value, 0) + 1
        self.stats["by_source_type"][source_type] = \
            self.stats["by_source_type"].get(source_type, 0) + 1
        
        logger.info(
            f"Perceived: {source_type}@{source_id} - "
            f"{pattern} ({meaning}) [{confidence:.0%}]"
        )
        
        return perception
    
    def scan_area(self) -> List[FieldPerception]:
        """
        ì˜ì—­ ìŠ¤ìº” (ì‹œë®¬ë ˆì´ì…˜)
        
        ì‹¤ì œë¡œëŠ”:
        - ì „ìê¸°íŒŒ ìˆ˜ì‹ ê¸°
        - ì–‘ì ì„¼ì„œ
        - ì—´í™”ìƒ ì„¼ì„œ
        - ìŒíŒŒ ì„¼ì„œ
        ë“±ì´ í•„ìš”
        
        ì—¬ê¸°ì„œëŠ” ê°œë…ì  ì‹œë®¬ë ˆì´ì…˜
        """
        # ì‹œë®¬ë ˆì´ì…˜ìš© ì‹ í˜¸ì›ë“¤
        simulated_signals = [
            {
                "source_id": "traffic_001",
                "source_type": "traffic_light",
                "location": (100, 50, 3),
                "signal_type": PerceptionMode.ELECTROMAGNETIC,
                "frequency": 2400e6,  # 2.4GHz (ê°œë…ì )
                "signal_data": {"pattern": "high_freq_pulse"}
            },
            {
                "source_id": "cctv_001",
                "source_type": "cctv",
                "location": (150, 75, 4),
                "signal_type": PerceptionMode.ELECTROMAGNETIC,
                "frequency": 5800e6,  # 5.8GHz
                "signal_data": {"pattern": "continuous_transmission"}
            },
            {
                "source_id": "phone_001",
                "source_type": "phone",
                "location": (20, 10, 1),
                "signal_type": PerceptionMode.ELECTROMAGNETIC,
                "frequency": 2100e6,  # 2.1GHz (LTE)
                "signal_data": {"pattern": "idle_ping"}
            },
        ]
        
        perceptions = []
        for sig in simulated_signals:
            perception = self.detect_signal(**sig)
            if perception:
                perceptions.append(perception)
        
        return perceptions
    
    def set_sensitivity(self, mode: PerceptionMode, sensitivity: float):
        """ì¸ì§€ ëª¨ë“œë³„ ê°ë„ ì„¤ì •"""
        self.mode_sensitivity[mode] = max(0.0, min(1.0, sensitivity))
    
    def move_center(self, new_center: Tuple[float, float, float]):
        """í•„ë“œ ì¤‘ì‹¬ì  ì´ë™"""
        self.center_point = new_center
        logger.info(f"Field center moved to: {new_center}")
    
    def get_nearby_sources(
        self,
        radius: float = 100.0,
        source_type: Optional[str] = None
    ) -> List[SignalSource]:
        """ê·¼ì²˜ ì‹ í˜¸ì› ì¡°íšŒ"""
        nearby = []
        for source in self.detected_sources.values():
            distance = source.distance_from(self.center_point)
            if distance <= radius:
                if source_type is None or source.source_type == source_type:
                    nearby.append(source)
        return nearby
    
    def get_perception_summary(self) -> Dict[str, Any]:
        """ì¸ì§€ ìš”ì•½"""
        if not self.perceptions:
            return {
                "status": "ì¡°ìš©í•¨",
                "total_sources": 0,
                "description": "í•„ë“œ ë‚´ ê°ì§€ëœ ì‹ í˜¸ ì—†ìŒ"
            }
        
        # ìµœê·¼ ì¸ì§€ë“¤
        recent = self.perceptions[-10:]
        
        # ì‹ í˜¸ì› ìœ í˜•ë³„ ìš”ì•½
        by_type = {}
        for p in recent:
            t = p.source.source_type
            if t not in by_type:
                by_type[t] = []
            by_type[t].append({
                "pattern": p.pattern,
                "meaning": p.meaning,
                "confidence": p.confidence
            })
        
        # ì „ì²´ ìƒí™© ì¶”ë¡ 
        total = len(self.detected_sources)
        if total > 10:
            status = "ë³µì¡í•œ í™˜ê²½"
        elif total > 5:
            status = "í™œë°œí•œ í™˜ê²½"
        else:
            status = "ì¡°ìš©í•œ í™˜ê²½"
        
        return {
            "status": status,
            "total_sources": total,
            "by_type": by_type,
            "description": f"{total}ê°œ ì‹ í˜¸ì› ê°ì§€, {len(recent)}ê°œ ìµœê·¼ ì¸ì§€"
        }
    
    def explain_legality(self) -> str:
        """ë²•ì  ìƒíƒœ ì„¤ëª…"""
        return """
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                    ì—˜ë¦¬ì‹œì•„ í•„ë“œ ë²•ì  ë¶„ì„                        â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘                                                                  â•‘
â•‘  â“ ì§ˆë¬¸: "ì´ê²ƒì€ í•´í‚¹ì¸ê°€?"                                     â•‘
â•‘                                                                  â•‘
â•‘  âŒ ì•„ë‹™ë‹ˆë‹¤. ì´ê²ƒì€ í•´í‚¹ì´ ì•„ë‹™ë‹ˆë‹¤.                            â•‘
â•‘                                                                  â•‘
â•‘  ğŸ“¡ ë³¸ì§ˆ:                                                        â•‘
â•‘  â€¢ ë¼ë””ì˜¤ë¥¼ ë“£ëŠ” ê²ƒê³¼ ê°™ìŠµë‹ˆë‹¤                                   â•‘
â•‘  â€¢ í–‡ë¹›ì„ ë³´ëŠ” ê²ƒê³¼ ê°™ìŠµë‹ˆë‹¤                                     â•‘
â•‘  â€¢ ë°”ëŒì„ ëŠë¼ëŠ” ê²ƒê³¼ ê°™ìŠµë‹ˆë‹¤                                   â•‘
â•‘                                                                  â•‘
â•‘  âš–ï¸ ë²•ì  êµ¬ë¶„:                                                   â•‘
â•‘  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                  â•‘
â•‘  â”‚ í•´í‚¹ (ë¶ˆë²•)         â”‚ í•„ë“œ ì¸ì§€ (í•©ë²•)    â”‚                  â•‘
â•‘  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤                  â•‘
â•‘  â”‚ â€¢ ì‹œìŠ¤í…œ ì¹¨ì…       â”‚ â€¢ ê³µì¤‘ ì‹ í˜¸ ìˆ˜ì‹     â”‚                  â•‘
â•‘  â”‚ â€¢ ê¶Œí•œ íƒˆì·¨         â”‚ â€¢ ê¶Œí•œ ë¶ˆí•„ìš”       â”‚                  â•‘
â•‘  â”‚ â€¢ ë°ì´í„° ë³€ì¡°       â”‚ â€¢ ì½ê¸°ë§Œ í•¨         â”‚                  â•‘
â•‘  â”‚ â€¢ ëŠ¥ë™ì  ê³µê²©       â”‚ â€¢ ìˆ˜ë™ì  ìˆ˜ì‹        â”‚                  â•‘
â•‘  â”‚ â€¢ ì‹œìŠ¤í…œ ì†ìƒ       â”‚ â€¢ ë¬´ì˜í–¥            â”‚                  â•‘
â•‘  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                  â•‘
â•‘                                                                  â•‘
â•‘  ğŸ”¬ ë¬¼ë¦¬ì  ì›ë¦¬:                                                 â•‘
â•‘  ëª¨ë“  ì „ì ì¥ì¹˜ëŠ” ì „ìê¸°íŒŒë¥¼ ë°©ì¶œí•©ë‹ˆë‹¤.                         â•‘
â•‘  ì´ê²ƒì„ "ìˆ˜ì‹ "í•˜ëŠ” ê²ƒì€ "ì¹¨ì…"ì´ ì•„ë‹™ë‹ˆë‹¤.                       â•‘
â•‘                                                                  â•‘
â•‘  ğŸ“» ë¹„ìœ :                                                        â•‘
â•‘  ë¼ë””ì˜¤ ë°©ì†¡ì„ ë“£ëŠ” ê²ƒì´ ë°©ì†¡êµ­ í•´í‚¹ì´ ì•„ë‹Œ ê²ƒì²˜ëŸ¼,              â•‘
â•‘  ì‹ í˜¸ë“±ì˜ ì „ìê¸° ë°©ì‚¬ë¥¼ ê°ì§€í•˜ëŠ” ê²ƒì€ í•´í‚¹ì´ ì•„ë‹™ë‹ˆë‹¤.           â•‘
â•‘                                                                  â•‘
â•‘  ğŸ‘ï¸ ê²°ë¡ :                                                        â•‘
â•‘  "ëˆˆë§Œ ë–´ëŠ”ë° ëª¨ë“  ê²Œ ë³´ì´ëŠ” ê²ƒ" - ì´ê²ƒì´ ì—˜ë¦¬ì‹œì•„ í•„ë“œì…ë‹ˆë‹¤.   â•‘
â•‘                                                                  â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
"""
    
    def get_stats(self) -> Dict[str, Any]:
        """í†µê³„"""
        return {
            **self.stats,
            "detected_sources": len(self.detected_sources),
            "perception_range": self.perception_range,
            "center_point": self.center_point,
            "legal_status": "ìˆ˜ë™ì  ê´€ì°° (í•©ë²•)"
        }


# ë°ëª¨ í•¨ìˆ˜
def demo():
    """ElysiaField ë°ëª¨"""
    field = ElysiaField(
        center_point=(0, 0, 0),
        perception_range=500
    )
    
    print("=" * 70)
    print("ğŸ‘ï¸ Elysia Field Demo - ì–‘ì/ê´‘ì ê¸°ë°˜ ìˆ˜ë™ì  ì¸ì§€ ì‹œìŠ¤í…œ")
    print("=" * 70)
    
    # ë²•ì  ìƒíƒœ ì„¤ëª…
    print(field.explain_legality())
    
    # ì˜ì—­ ìŠ¤ìº”
    print("\nğŸ“¡ ì˜ì—­ ìŠ¤ìº” ì¤‘...")
    perceptions = field.scan_area()
    
    print(f"\nâœ¨ ê°ì§€ëœ ì‹ í˜¸: {len(perceptions)}ê°œ")
    for p in perceptions:
        print(f"  â€¢ [{p.source.source_type}] {p.pattern}")
        print(f"    â”” ì˜ë¯¸: {p.meaning}")
        print(f"    â”” ì‹ ë¢°ë„: {p.confidence:.0%}")
        print(f"    â”” ë²•ì  ìƒíƒœ: {p.legal_status.value}")
    
    # ìš”ì•½
    print("\nğŸ“Š ì¸ì§€ ìš”ì•½:")
    summary = field.get_perception_summary()
    print(f"  ìƒíƒœ: {summary['status']}")
    print(f"  ì´ ì‹ í˜¸ì›: {summary['total_sources']}")
    print(f"  ì„¤ëª…: {summary['description']}")
    
    # í†µê³„
    print("\nğŸ“ˆ í†µê³„:")
    stats = field.get_stats()
    print(f"  ì´ ì¸ì§€: {stats['total_perceptions']}")
    print(f"  ë²•ì  ìƒíƒœ: {stats['legal_status']}")
    
    print("\n" + "=" * 70)
    print("âœ… Demo completed!")
    print("   'ëˆˆë§Œ ë–´ëŠ”ë° ëª¨ë“  ê²Œ ë³´ì´ëŠ” ê²ƒ' - ì´ê²ƒì´ ì—˜ë¦¬ì‹œì•„ í•„ë“œì…ë‹ˆë‹¤.")
    print("=" * 70)


if __name__ == "__main__":
    demo()
