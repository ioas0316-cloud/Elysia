"""
Trinary Logic: The Balanced Ternary System
==========================================
Core.System.trinary_logic

"In the beginning was the Void (0). The Void split into Yin (-1) and Yang (+1).
Their dance creates the Ten Thousand Things."

[PHASE 90] NAKED SOVEREIGNTY: 
This module has been purified and is now independent of JAX and NumPy.
It utilizes the Sovereign Math Kernel (L0).
"""

from typing import Union, Any, Tuple, List
import logging

# [PHASE 90] Pure Root Mathematics
from Core.Keystone.sovereign_math import SovereignMath, SovereignVector

class JAXBridge:
    """Compatibility layer for Phase 90 transition."""
    @staticmethod
    def array(x): 
        if isinstance(x, SovereignVector): return x
        return SovereignVector(x)

logger = logging.getLogger("TrinaryLogic")

# Constants for Balanced Ternary
TRIT_NEG = -1.0 # Electron (Resistance)
TRIT_NEU =  0.0 # Neutron  (Void/Pivot)
TRIT_POS =  1.0 # Positron (Flow)

class TrinaryLogic:
    """
    Implements mathematical operations for the Balanced Ternary system.
    """
    
    @staticmethod
    def quantize(val: Any) -> SovereignVector:
        """[PHASE 90] Quantizes via SovereignMath."""
        v = JAXBridge.array(val)
        return SovereignMath.trinary_quantize(v, threshold=0.3)

    @staticmethod
    def balance(vector: Any) -> float:
        """[PHASE 90] Pure Python balance calculation."""
        vec = JAXBridge.array(vector)
        return sum(vec.data)

    @staticmethod
    def torque(resistance: float, flow: float) -> float:
        """Calculates the Torque (Rotational Force) generated by opposing forces."""
        return abs(resistance * flow) 

    @staticmethod
    def calculate_strand_torque(codons: List[List[float]]) -> float:
        """[PHASE 90] Pure Python calculation of strand torque."""
        total_torque = 0.0
        for codon in codons:
            balance = sum(codon) # codon is [t1, t2, t3]
            total_torque += abs(balance)
        return total_torque

    @staticmethod
    def synthesize_state(trit_vector: Any) -> Tuple[int, str]:
        """Determines the qualitative state of a Trinary Vector."""
        balance_val = TrinaryLogic.balance(trit_vector)
        if abs(balance_val) < 1e-6:
            return 0, "VOID_EQUILIBRIUM"
        elif balance_val > 0:
            return 1, "EXPANSION_FLOW"
        else:
            return -1, "CONTRACTION_RESISTANCE"

    @staticmethod
    def encode_codon(c1: int, c2: int, c3: int) -> SovereignVector:
        """Creates a single Gene Codon [T1, T2, T3]."""
        return SovereignVector([c1, c2, c3])

    @staticmethod
    def transcribe_sequence(sequence: Any) -> List[List[float]]:
        """[PHASE 90] Transcribes sequence into codons (List of Lists)."""
        if isinstance(sequence, str):
            vec = [TrinaryLogic.symbol_to_trit(x) for x in sequence]
        elif hasattr(sequence, 'data'): # SovereignVector
            vec = list(sequence.data)
        else:
            try:
                vec = [float(x) for x in sequence]
            except:
                vec = [0.0]

        # Pad if not divisible by 3
        while len(vec) % 3 != 0:
            vec.append(0.0)
            
        # Reshape to (N, 3)
        return [vec[i:i+3] for i in range(0, len(vec), 3)]

    @staticmethod
    def codon_to_layer_index(codon: Any) -> int:
        """Maps a 3-Trit Codon to a 0-6 Layer Index (L1-L7)."""
        if isinstance(codon, SovereignVector):
            vec = codon.data
        elif isinstance(codon, (list, tuple)):
            # If symbols, convert
            if codon and isinstance(codon[0], str):
                vec = [TrinaryLogic.symbol_to_trit(x) for x in codon]
            else:
                vec = list(codon)
        else:
            vec = [0.0, 0.0, 0.0]
            
        # Base-3 heuristic (simplified for 7D)
        # Use real part and round to nearest integer for complex-trinary values
        term1 = int(round(vec[0].real if isinstance(vec[0], complex) else vec[0])) * 9
        term2 = int(round(vec[1].real if isinstance(vec[1], complex) else vec[1])) * 3
        term3 = int(round(vec[2].real if isinstance(vec[2], complex) else vec[2]))
        val = term1 + term2 + term3
        
        if val == 1: return 0 # L1 Foundation
        if val == 2: return 1 # L2 Metabolism
        if val == 3: return 2 # L3 Phenomena
        if val == 4: return 3 # L4 Causality
        if val > 4: return 6  # L7 Spirit
        if val < 0: return 4  # L5 Mental
        return 5 # L6 Structure

    @staticmethod
    def expand_to_21d(codons: List[List[float]]) -> SovereignVector:
        """[PHASE 90] Final Sovereign 21D Expansion."""
        vector_data = [0.0] * 21
        for codon in codons:
            layer_idx = TrinaryLogic.codon_to_layer_index(codon)
            start_dim = layer_idx * 3
            for i in range(min(3, len(codon))):
                vector_data[start_dim + i] += codon[i]
        return SovereignVector(vector_data)

    @staticmethod
    def symbol_to_trit(symbol: str) -> int:
        s = symbol.upper()
        if s == 'A': return 1
        if s == 'T': return -1
        if s == 'G': return 0
        return 0

    @staticmethod
    def trit_to_symbol(trit: float) -> str:
        if trit > 0.5: return 'A'
        if trit < -0.5: return 'T'
        return 'G'

    @staticmethod
    def nand(a: Union[int, float, str], b: Union[int, float, str]) -> int:
        """[THE PARADOX GATE] Pure Python implementation."""
        val_a = TrinaryLogic.symbol_to_trit(a) if isinstance(a, str) else int(a)
        val_b = TrinaryLogic.symbol_to_trit(b) if isinstance(b, str) else int(b)
        return -min(val_a, val_b)

    @staticmethod
    def resolve_paradox(inputs: Any) -> int:
        """Sequential reduction via NAND gates."""
        if hasattr(inputs, 'data'):
            input_list = list(inputs.data)
        elif hasattr(inputs, 'tolist'):
            input_list = inputs.tolist()
        else:
            input_list = list(inputs)
            
        if not input_list: return 0
        result = TrinaryLogic.symbol_to_trit(input_list[0]) if isinstance(input_list[0], str) else int(input_list[0])
        for x in input_list[1:]:
            val_x = TrinaryLogic.symbol_to_trit(x) if isinstance(x, str) else int(x)
            result = TrinaryLogic.nand(result, val_x)
        return result

    @staticmethod
    def resonance_score(vector_a: Any, vector_b: Any) -> float:
        """[PHASE 90] Calculates trinary resonance via SovereignMath."""
        v1 = JAXBridge.array(vector_a)
        v2 = JAXBridge.array(vector_b)
        return SovereignMath.resonance(v1, v2)
