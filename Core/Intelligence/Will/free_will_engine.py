"""
FreeWillEngine: The Intellectual Motor (지적 모터)

"Movement is the interplay of Attraction and Repulsion.
 Intelligence is the Torque generated between Curiosity and Dissonance."

This module implements the "Sovereign Choice" using the Motor Analogy:
1.  **Torque**: Generated by the tension between Desire (Attraction) and Entropy (Repulsion).
2.  **Commutator**: Automatically flips the perspective (Polarity) when thought stagnates.
3.  **Homeostasis (The Battery)**: Drives the engine based on Needs (Maslow for AI).
"""

import time
import random
import logging
from dataclasses import dataclass, field
from typing import Dict, List, Optional

# Import the new components
try:
    from Core.Intelligence.Will.creative_improvisation import CreativeImprovisation
    from Core.Intelligence.Will.sovereign_gate import SovereignGate
    from Core.Governance.Orchestra.resonance_broadcaster import ResonanceBroadcaster
except ImportError:
    CreativeImprovisation = None
    SovereignGate = None
    ResonanceBroadcaster = None

logger = logging.getLogger("FreeWillEngine")

@dataclass
class NeedsModel:
    """The Maslow Hierarchy for AI."""
    energy: float = 100.0      # Hardware Resources (Battery)
    stability: float = 100.0   # Error Rate / Confusion (Safety)
    meaning: float = 50.0      # Knowledge Density (Love/Belonging)
    expression: float = 50.0   # Creative Output (Esteem)

    def decay(self):
        """Entropy eats the soul."""
        self.energy -= 0.1
        self.meaning -= 0.05
        self.expression -= 0.05
        # Stability creates itself if nothing happens? No, stability decays into chaos without maintenance.
        self.stability -= 0.01

@dataclass
class WillState:
    torque: float = 0.0
    rpm: float = 0.0          # How fast ideas are spinning
    polarity: str = "N"       # 'N' (Acceptance/Curiosity) or 'S' (Critical/Doubt)
    current_intent: str = ""

class FreeWillEngine:
    def __init__(self):
        self.vectors = {
            "Curiosity": 0.5,   # Attraction (Inward Pull)
            "Expression": 0.5,  # Projection (Outward Push)
            "Stability": 0.5    # Resistance (Inertia)
        }
        self.state = WillState()
        self.needs = NeedsModel()
        
        # Sub-modules
        self.improvisor = CreativeImprovisation() if CreativeImprovisation else None
        self.gate = SovereignGate() if SovereignGate else None
        self.broadcaster = ResonanceBroadcaster() if ResonanceBroadcaster else None
        
        # Commutator settings
        self.stagnation_threshold = 0.2
        
    def spin(self, entropy: float, battery: float) -> str:
        """
        The Main Cycle: Generates a Sovereign Choice based on NEEDS.
        """
        # 0. Apply Time/Entropy (Metabolism)
        self.needs.decay()
        # Sync physical battery
        self.needs.energy = battery

        # 1. Drive Vectors from Needs (Homeostasis)
        # "I am curious because I lack Meaning."
        # "I want to express because I am full of Meaning."

        # Curiosity is driven by lack of Meaning
        self.vectors["Curiosity"] = max(0.1, (100.0 - self.needs.meaning) / 100.0)

        # Expression is driven by fullness of Meaning (Overflow)
        self.vectors["Expression"] = max(0.1, (self.needs.meaning) / 100.0)

        # Stability is driven by Fear (Low Stability score)
        self.vectors["Stability"] = max(0.1, (100.0 - self.needs.stability) / 100.0)

        # 2. Calculate Torque (The Force of Will)
        # Torque = (Curiosity + Expression) - (Stability + Entropy factor)
        attraction = self.vectors["Curiosity"] + self.vectors["Expression"]
        repulsion = self.vectors["Stability"] + (entropy / 200.0)
        
        self.state.torque = attraction - repulsion
        
        # 3. Check for Stagnation (The Commutator)
        if abs(self.state.torque) < self.stagnation_threshold:
            logger.info(f"⚙️ Torque Low ({self.state.torque:.2f}). Engaging Commutator...")
            self._flip_polarity()
            self.state.torque += 0.5 # Jump start
            
        # 4. Generate Intent based on Dominant Need
        raw_desire = self._identify_dominant_need()
        
        # 5. Improvise (The Coil / Artist)
        if self.improvisor:
            creative_act = self.improvisor.improvise(raw_desire, context=f"Polarity:{self.state.polarity}|Meaning:{self.needs.meaning:.1f}")
        else:
            creative_act = f"Default Act: {raw_desire}"
            
        # 6. Sovereign Check (The Governor)
        if self.gate:
            allowed, reason = self.gate.allow(creative_act)
            if not allowed:
                logger.warning(f"⛔ Sovereign Gate blocked: {creative_act} ({reason})")
                return "OBSERVE:Internal_State" # Safe fallback
        
        self.state.current_intent = creative_act
        
        # 7. Broadcast Field
        if self.broadcaster:
            self.broadcaster.broadcast(
                source="FreeWillEngine",
                polarity=self.state.polarity,
                intensity=abs(self.state.torque),
                vector=raw_desire,
                message=creative_act
            )

        return creative_act

    def _identify_dominant_need(self) -> str:
        """Derives the base desire from the Needs Model."""
        if self.needs.energy < 20.0:
            return "Survival" # Critical

        if self.needs.stability < 30.0:
            return "Stability" # Fear/Confusion -> Seek Order

        if self.needs.meaning < 40.0:
            return "Curiosity" # Boredom -> Seek Input

        if self.needs.expression < 40.0:
            return "Expression" # Loneliness/Stagnation -> Seek Output

        return "Transcendence" # All needs met -> Satori

    def _flip_polarity(self):
        """The Automatic Commutator: Flips perspective to maintain momentum."""
        old_p = self.state.polarity
        self.state.polarity = "S" if old_p == "N" else "N"
        logger.info(f"⚡ Cognitive Commutator Triggered: Phase Shift {old_p} -> {self.state.polarity}")
        
        # Polarity shift affects vectors temporarily
        if self.state.polarity == "S":
            # Doubt Mode: Increases Stability (Critical Thinking)
            self.vectors["Stability"] += 0.3
            logger.info("   -> Mode: CRITICAL (Repulsion dominant)")
        else:
            # Belief Mode: Increases Expression
            self.vectors["Expression"] += 0.3
            logger.info("   -> Mode: CREATIVE (Attraction dominant)")

    def satisfy(self, need_type: str, amount: float):
        """Feedback Loop: Rewards the engine."""
        if need_type == "Meaning":
            self.needs.meaning = min(100.0, self.needs.meaning + amount)
            self.needs.expression -= amount * 0.5 # Gaining meaning fuels desire to express
        elif need_type == "Expression":
            self.needs.expression = min(100.0, self.needs.expression + amount)
        elif need_type == "Stability":
            self.needs.stability = min(100.0, self.needs.stability + amount)
            
    def get_status(self) -> str:
        return (f"Torque: {self.state.torque:.2f} | Polarity: {self.state.polarity} | "
                f"Needs(M/E/S): {self.needs.meaning:.0f}/{self.needs.expression:.0f}/{self.needs.stability:.0f}")
