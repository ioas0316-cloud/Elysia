"""
Rotor (자전축 로터)
==================================

"The Rotor is the Oscillator."
"로터가 곧 진동자다."

This module defines the Physical Rotor that powers the Hyper-Cosmos.
It acts as:
1. Information Centrifuge (Purification)
2. Wave Generator (Oscillation)

Philosophy:
- The System never "dies" (0 RPM). It only "sleeps" (Low RPM).
- Sleep Mode = Breathing (Low-Power Frequency Maintenance).
- Active Mode = Awakening (High-Power Acceleration).
"""

from dataclasses import dataclass
import math

@dataclass
class RotorConfig:
    """로터 설정"""
    rpm: float = 0.0          # Active Target RPM (Awake)
    idle_rpm: float = 60.0    # Sleep/Breathing RPM (Default 1Hz)
    mass: float = 1.0         # Amplitude proxy
    axis_tilt: float = 23.5   # Z-axis orientation
    acceleration: float = 100.0 # RPM per second (Wake-up Speed)

class Rotor:
    """
    Spectral Rotor: A Multi-Harmonic Oscillator.
    ============================================
    Unlike a simple motor (1 frequency), a Spectral Rotor holds a 'Chord'.
    It spins at multiple frequencies simultaneously, representing a complex thought.
    
    Structure:
    - Base RPM: The carrier wave.
    - Spectrum: List of (Hz, Amp, Phase) harmonics.
    """
    def __init__(self, name: str, config: RotorConfig):
        self.name = name
        self.config = config

        # Dynamic State
        self.current_angle = 0.0 # Phase (Degrees)
        self.current_rpm = 0.0   # Current Velocity
        self.target_rpm = 0.0    # Desired Velocity
        self.is_spinning = False # Technical flag for "Engine On"
        
        # [PHASE 65] Spectral State (The Prism Output)
        # List of (Frequency Hz, Amplitude 0-1, Phase Offset Rad)
        self.spectrum: list[tuple[float, float, float]] = []
        
        # [PHASE 66] Dynamic Qualia (The Nature)
        # We store the WaveDynamics object here
        self.dynamics = None
        
        # [PHASE 64] 4D Position (Hyper-Quaternion)
        self.position_4d = (0.0, 0.0, 0.0, 0.0)

    @property
    def frequency_hz(self) -> float:
        """Convert Current RPM to Hz"""
        return self.current_rpm / 60.0

    def spin_up(self):
        """Wake up: Accelerate to Active RPM."""
        self.is_spinning = True
        self.target_rpm = self.config.rpm

    def spin_down(self):
        """Sleep: Decelerate to Breathing RPM (Never Stop)."""
        self.is_spinning = True # Engine is still on!
        self.target_rpm = self.config.idle_rpm

    def update(self, dt: float):
        """
        Advance phase and interpolate RPM.
        """
        if not self.is_spinning:
            return

        # 1. Update RPM (Smooth Acceleration - The Breath)
        if self.current_rpm != self.target_rpm:
            diff = self.target_rpm - self.current_rpm
            change = self.config.acceleration * dt

            if abs(diff) < change:
                self.current_rpm = self.target_rpm
            else:
                self.current_rpm += change * (1 if diff > 0 else -1)

        # 2. Update Phase
        # Revolutions per second * 360 degrees * dt
        if self.current_rpm > 0:
            degrees_per_sec = (self.current_rpm / 60.0) * 360.0
            self.current_angle = (self.current_angle + degrees_per_sec * dt) % 360.0

    def get_wave_component(self) -> tuple[float, float, float]:
        """
        Returns the wave component generated by this rotor at current angle.
        Returns: (Frequency Hz, Amplitude (Mass), Phase Radians)
        """
        phase_rad = math.radians(self.current_angle)
        return (self.frequency_hz, self.config.mass, phase_rad)
    
    def inject_spectrum(self, spectrum: list[tuple[float, float, float]], dynamics=None):
        """
        [PHASE 65] Loads a complex harmonic profile into the rotor.
        [PHASE 66] Also loads dynamic qualia if provided.
        """
        self.spectrum = spectrum
        if dynamics:
             self.dynamics = dynamics
        
    def resonate(self, other_rotor: 'Rotor') -> float:
        """
        [PHASE 65] Calculates interference/resonance with another rotor.
        Returns a value between -1.0 (Dissonance) and 1.0 (Resonance).
        
        Uses spectral overlap calculation.
        """
        # Simple implementation for now: dot product of spectra if they match
        # Real implementation requires manifold integration
        if not self.spectrum or not other_rotor.spectrum:
            return 0.0
            
        # Compare primary frequencies
        f1 = self.frequency_hz
        f2 = other_rotor.frequency_hz
        
        # Harmonic ratio check
        ratio = f1 / f2 if f2 > 0 else 0
        
        # Perfect fifth (1.5) or Octave (2.0) or Unison (1.0) is resonant
        if abs(ratio - 1.0) < 0.01: return 1.0
        if abs(ratio - 1.5) < 0.01: return 0.8
        if abs(ratio - 2.0) < 0.01: return 0.9
        
        return 0.1 # Weak resonance
        
    def adapt(self, action: str, param: float):
        """
        [PHASE 67] Autopoietic Adaptation.
        The Rotor adjusts itself based on feedback from the Manifold.
        """
        if action == "SHIFT_PHASE":
            # Physically shift the phase of the rotor to dodge interference
            # param is radians
            degrees = math.degrees(param)
            self.current_angle = (self.current_angle + degrees) % 360.0
            print(f"   ⚙️ Rotor '{self.name}' shifted phase by {degrees:.1f}°")
            
        elif action == "DAMPEN":
            # Reduce mass (amplitude) to reduce noise contribution
            # param is multiplier (e.g., 0.9)
            old_mass = self.config.mass
            self.config.mass *= param
            if self.config.mass < 0.1: self.config.mass = 0.1 # Minimum mass
            print(f"   ⚙️ Rotor '{self.name}' dampened mass: {old_mass:.2f} -> {self.config.mass:.2f}")
            
        elif action == "RETUNE":
            # Change frequency to find harmony
            # param is multiplier (e.g. 1.059 for semitone up)
            self.target_rpm *= param
            print(f"   ⚙️ Rotor '{self.name}' retuning RPM: {self.target_rpm:.1f}")
        

    def purify(self, raw_data: dict) -> dict:
        """Legacy Centrifuge Logic"""
        if not self.is_spinning: return raw_data
        essence = {}
        for k, v in raw_data.items():
            if v is None: continue
            if len(str(k)) > 20: continue
            if isinstance(v, str) and len(v) > 50: continue
            essence[k] = v
        return essence

    def __repr__(self):
        state = "Sleep" if self.current_rpm <= self.config.idle_rpm else "Awake"
        harmonics = len(self.spectrum)
        return f"Rotor({self.name} | {state} | {self.current_rpm:.1f} RPM | H:{harmonics})"
